From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: KurumiFake <kurumiisshidowife@gmail.com>
Date: Sun, 23 Jan 2022 08:14:19 +0700
Subject: [PATCH] Rebrand and misc

- Rebrand
- Bump dependencies
- Purpur dependencies
- Hardcode BukkitVersion

diff --git a/build.gradle.kts b/build.gradle.kts
index 3823eaa2facbe9cb1dfaa81801e3686228a53909..ed8c4cdd9ec0ffe53af746df773ae25fe762caa9 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -22,7 +22,7 @@ repositories {
 }
 
 dependencies {
-    implementation(project(":Airplane-API")) // Airplane // Paper
+    implementation(project(":Fiadelity-API")) // Fiadelity // Airplane // Paper
     implementation("io.papermc.paper:paper-mojangapi:1.17.1-R0.1-SNAPSHOT") // Airplane
     // Paper start
     implementation("org.jline:jline-terminal-jansi:3.21.0")
@@ -45,18 +45,20 @@ dependencies {
         // This includes junit transitively for whatever reason
         isTransitive = false
     }
-    runtimeOnly("org.xerial:sqlite-jdbc:3.34.0")
-    runtimeOnly("mysql:mysql-connector-java:8.0.23") // Paper
+    runtimeOnly("org.xerial:sqlite-jdbc:3.36.0.3")
+    runtimeOnly("mysql:mysql-connector-java:8.0.28") // Paper
     runtimeOnly("com.lmax:disruptor:3.4.4") // Paper
 
-    runtimeOnly("org.apache.maven:maven-resolver-provider:3.8.1")
-    runtimeOnly("org.apache.maven.resolver:maven-resolver-connector-basic:1.7.0")
-    runtimeOnly("org.apache.maven.resolver:maven-resolver-transport-http:1.7.0")
+    runtimeOnly("org.apache.maven:maven-resolver-provider:3.8.4")
+    runtimeOnly("org.apache.maven.resolver:maven-resolver-connector-basic:1.7.3")
+    runtimeOnly("org.apache.maven.resolver:maven-resolver-transport-http:1.7.3")
 
-    implementation("io.netty:netty-all:4.1.65.Final") // Paper
+    implementation("io.netty:netty-all:4.1.73.Final") // Paper
+    implementation("cat.inspiracio:rhino-js-engine:1.7.7.1") // Purpur
+    implementation("dev.omega24:upnp4j:1.0") // Purpur
 
     implementation("net.fabricmc:mapping-io:0.3.0") // Paper - needed to read mappings for stacktrace deobfuscation
-    implementation("com.velocitypowered:velocity-native:1.1.0-SNAPSHOT") // Paper
+    implementation("com.velocitypowered:velocity-native:1.1.10-SNAPSHOT") // Paper
 
     implementation("com.github.technove:AIR:fe3dbb4420") // Airplane - config
     implementation("org.yaml:snakeyaml:1.28")
@@ -67,8 +69,8 @@ dependencies {
 
     implementation("io.sentry:sentry:5.4.0") // Airplane
 
-    testImplementation("io.github.classgraph:classgraph:4.8.47") // Paper - mob goal test
-    testImplementation("junit:junit:4.13.1")
+    testImplementation("io.github.classgraph:classgraph:4.8.138") // Paper - mob goal test
+    testImplementation("junit:junit:4.13.2")
     testImplementation("org.hamcrest:hamcrest-library:1.3")
 }
 
@@ -85,7 +87,7 @@ tasks.jar {
             "Main-Class" to "org.bukkit.craftbukkit.Main",
             "Implementation-Title" to "CraftBukkit",
             "Implementation-Version" to "git-Paper-$implementationVersion",
-            "Implementation-Version" to "git-Airplane-$implementationVersion", // Airplane
+            "Implementation-Version" to "git-Fiadelity-$implementationVersion", // Fiadelity
             "Implementation-Vendor" to date, // Paper
             "Specification-Title" to "Bukkit",
             "Specification-Version" to project.version,
diff --git a/src/main/java/com/destroystokyo/paper/Metrics.java b/src/main/java/com/destroystokyo/paper/Metrics.java
index f5d01bce4d5547b4aeca96b7962b2090f47ea541..47dc6277dd666ac4d134ec47a308e48a00f0d57e 100644
--- a/src/main/java/com/destroystokyo/paper/Metrics.java
+++ b/src/main/java/com/destroystokyo/paper/Metrics.java
@@ -593,7 +593,7 @@ public class Metrics {
             boolean logFailedRequests = config.getBoolean("logFailedRequests", false);
             // Only start Metrics, if it's enabled in the config
             if (config.getBoolean("enabled", true)) {
-                Metrics metrics = new Metrics("Airplane", serverUUID, logFailedRequests, Bukkit.getLogger()); // Tuinity - we have our own bstats page // Airplane
+                Metrics metrics = new Metrics("Fiadelity", serverUUID, logFailedRequests, Bukkit.getLogger()); // Tuinity - we have our own bstats page // Fiadelity
 
                 metrics.addCustomChart(new Metrics.SimplePie("minecraft_version", () -> {
                     String minecraftVersion = Bukkit.getVersion();
@@ -603,7 +603,7 @@ public class Metrics {
 
                 metrics.addCustomChart(new Metrics.SingleLineChart("players", () -> Bukkit.getOnlinePlayers().size()));
                 metrics.addCustomChart(new Metrics.SimplePie("online_mode", () -> Bukkit.getOnlineMode() ? "online" : "offline"));
-                metrics.addCustomChart(new Metrics.SimplePie("airplane_version", () -> (Metrics.class.getPackage().getImplementationVersion() != null) ? Metrics.class.getPackage().getImplementationVersion() : "unknown")); // Tuinity - we have our own bstats page // Airplane
+                metrics.addCustomChart(new Metrics.SimplePie("fiadelity_version", () -> (Metrics.class.getPackage().getImplementationVersion() != null) ? Metrics.class.getPackage().getImplementationVersion() : "unknown")); // Tuinity - we have our own bstats page // Fiadelity
 
                 metrics.addCustomChart(new Metrics.DrilldownPie("java_version", () -> {
                     Map<String, Map<String, Integer>> map = new HashMap<>();
diff --git a/src/main/java/gg/airplane/AirplaneVersionFetcher.java b/src/main/java/gg/airplane/AirplaneVersionFetcher.java
index e79ec7919e6cf160fec1cb981d85f0f33c316b41..3809a187df08e9ed43e39703cef6a42633a5a5a8 100644
--- a/src/main/java/gg/airplane/AirplaneVersionFetcher.java
+++ b/src/main/java/gg/airplane/AirplaneVersionFetcher.java
@@ -31,8 +31,8 @@ public class AirplaneVersionFetcher implements VersionFetcher {
     private static final Logger LOGGER = Logger.getLogger("AirplaneVersionFetcher");
     private static final HttpClient client = HttpClient.newHttpClient();
 
-    private static final URI JENKINS_URI = URI.create("https://ci.tivy.ca/job/Airplane-1.17/lastSuccessfulBuild/buildNumber");
-    private static final String GITHUB_FORMAT = "https://api.github.com/repos/TECHNOVE/Airplane/compare/ver/1.17...%s";
+    // private static final URI JENKINS_URI = URI.create("https://ci.tivy.ca/job/Airplane-1.17/lastSuccessfulBuild/buildNumber");
+    private static final String GITHUB_FORMAT = "https://api.github.com/repos/KurumiFake/Fiadelity/compare/ver/1.17.1...%s"; // Fiadelity
 
     private static final HttpResponse.BodyHandler<JsonObject> JSON_OBJECT_BODY_HANDLER = responseInfo -> HttpResponse.BodySubscribers.mapping(
             HttpResponse.BodySubscribers.ofString(StandardCharsets.UTF_8),
@@ -54,18 +54,18 @@ public class AirplaneVersionFetcher implements VersionFetcher {
         } else {
             final String versionString = parts[2];
 
-            try {
+            /*try { // Fiadelity - ill never hav a jenkins tbh
                 component = this.fetchJenkinsVersion(Integer.parseInt(versionString));
-            } catch (NumberFormatException e) {
-                component = this.fetchGithubVersion(versionString.substring(1, versionString.length() - 1));
-            }
+            } catch (NumberFormatException e) {*/
+            component = this.fetchGithubVersion(versionString.substring(1, versionString.length() - 1));
+            
         }
 
         final @Nullable Component history = this.getHistory();
         return history != null ? Component.join(JoinConfiguration.noSeparators(), component, Component.newline(), this.getHistory()) : component;
     }
 
-    private @NotNull Component fetchJenkinsVersion(final int versionNumber) {
+    /*private @NotNull Component fetchJenkinsVersion(final int versionNumber) { // Fiadelity - ill never hav a jenkins tbh
         final HttpRequest request = HttpRequest.newBuilder(JENKINS_URI).build();
         try {
             final HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
@@ -87,7 +87,7 @@ public class AirplaneVersionFetcher implements VersionFetcher {
             LOGGER.log(Level.WARNING, "Failed to look up version from Jenkins", e);
             return text("Failed to retrieve version from server.", RED);
         }
-    }
+    }*/
 
     // Based off code contributed by Techcable <Techcable@outlook.com> in Paper/GH-65
     private @NotNull Component fetchGithubVersion(final @NotNull String hash) {
@@ -112,7 +112,7 @@ public class AirplaneVersionFetcher implements VersionFetcher {
     private @NotNull Component getResponseMessage(final int versionDiff) {
         return switch (Math.max(-1, Math.min(1, versionDiff))) {
             case -1 ->
-                text("You are running an unsupported version of Airplane.", RED);
+                text("You are running an unsupported version of Fiadelity.", RED);
             case 0 ->
                 text("You are on the latest version!", GREEN);
             default ->
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 7120a77ec93009faf1f18fd6c9bc020de66a5f73..691a44d81ed497a8677404508171874afda346d3 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1729,7 +1729,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     @DontObfuscate
     public String getServerModName() {
-        return "Airplane"; // Airplane // Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "Fiadelity"; // Fiadelity // Airplane // Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public SystemReport fillSystemReport(SystemReport details) {
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java.orig b/src/main/java/net/minecraft/server/MinecraftServer.java.orig
new file mode 100644
index 0000000000000000000000000000000000000000..4b361a027addefcc21ca4d0ec6fc1e74e03b002c
--- /dev/null
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java.orig
@@ -0,0 +1,2697 @@
+package net.minecraft.server;
+
+import com.google.common.base.Splitter;
+import com.google.common.collect.ImmutableList;
+import co.aikar.timings.Timings;
+import com.destroystokyo.paper.event.server.PaperServerListPingEvent;
+import com.google.common.base.Stopwatch;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.GameProfileRepository;
+import com.mojang.authlib.minecraft.MinecraftSessionService;
+import com.mojang.datafixers.DataFixer;
+import io.papermc.paper.adventure.PaperAdventure; // Paper
+import it.unimi.dsi.fastutil.longs.LongIterator;
+import java.awt.GraphicsEnvironment;
+import java.awt.image.BufferedImage;
+import java.io.BufferedWriter;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.lang.management.ManagementFactory;
+import java.lang.management.ThreadInfo;
+import java.lang.management.ThreadMXBean;
+import java.net.Proxy;
+import java.net.URLEncoder;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.security.KeyPair;
+import java.text.SimpleDateFormat;
+import java.util.Arrays;
+import java.util.Base64;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.Random;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.BooleanSupplier;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.stream.Stream;
+import javax.annotation.Nullable;
+import javax.imageio.ImageIO;
+import net.minecraft.CrashReport;
+import net.minecraft.ReportedException;
+import net.minecraft.SharedConstants;
+import net.minecraft.SystemReport;
+import net.minecraft.Util;
+import net.minecraft.commands.CommandSource;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.MappedRegistry;
+import net.minecraft.core.Registry;
+import net.minecraft.core.RegistryAccess;
+import net.minecraft.core.Vec3i;
+import net.minecraft.data.worldgen.Features;
+import net.minecraft.gametest.framework.GameTestTicker;
+import net.minecraft.nbt.NbtOps;
+import net.minecraft.nbt.Tag;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.TextComponent;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundChangeDifficultyPacket;
+import net.minecraft.network.protocol.game.ClientboundSetTimePacket;
+import net.minecraft.network.protocol.status.ServerStatus;
+import net.minecraft.obfuscate.DontObfuscate;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.DemoMode;
+import net.minecraft.server.level.PlayerRespawnLogic;
+import net.minecraft.server.level.ServerChunkCache;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.level.ServerPlayerGameMode;
+import net.minecraft.server.level.TicketType;
+import net.minecraft.server.level.progress.ChunkProgressListener;
+import net.minecraft.server.level.progress.ChunkProgressListenerFactory;
+import net.minecraft.server.network.ServerConnectionListener;
+import net.minecraft.server.network.TextFilter;
+import net.minecraft.server.packs.repository.Pack;
+import net.minecraft.server.packs.repository.PackRepository;
+import net.minecraft.server.packs.resources.ResourceManager;
+import net.minecraft.server.players.GameProfileCache;
+import net.minecraft.server.players.PlayerList;
+import net.minecraft.server.players.ServerOpListEntry;
+import net.minecraft.server.players.UserWhiteList;
+import net.minecraft.tags.BlockTags;
+import net.minecraft.tags.TagContainer;
+import net.minecraft.util.Crypt;
+import net.minecraft.util.CryptException;
+import net.minecraft.util.FrameTimer;
+import net.minecraft.util.Mth;
+import net.minecraft.util.ProgressListener;
+import net.minecraft.util.Unit;
+import net.minecraft.util.datafix.DataFixers;
+import net.minecraft.util.profiling.EmptyProfileResults;
+import net.minecraft.util.profiling.ProfileResults;
+import net.minecraft.util.profiling.ProfilerFiller;
+import net.minecraft.util.profiling.ResultField;
+import net.minecraft.util.profiling.SingleTickProfiler;
+import net.minecraft.util.profiling.metrics.profiling.ActiveMetricsRecorder;
+import net.minecraft.util.profiling.metrics.profiling.InactiveMetricsRecorder;
+import net.minecraft.util.profiling.metrics.profiling.MetricsRecorder;
+import net.minecraft.util.profiling.metrics.profiling.ServerMetricsSamplersProvider;
+import net.minecraft.util.profiling.metrics.storage.MetricsPersister;
+import net.minecraft.util.thread.ReentrantBlockableEventLoop;
+import net.minecraft.world.Difficulty;
+// import net.minecraft.world.Snooper;
+// import net.minecraft.world.SnooperPopulator;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.ai.village.VillageSiege;
+import net.minecraft.world.entity.npc.CatSpawner;
+import net.minecraft.world.entity.npc.WanderingTraderSpawner;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.crafting.RecipeManager;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.CustomSpawner;
+import net.minecraft.world.level.DataPackConfig;
+import net.minecraft.world.level.ForcedChunksSavedData;
+import net.minecraft.world.level.GameRules;
+import net.minecraft.world.level.GameType;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.LevelSettings;
+import net.minecraft.world.level.biome.BiomeManager;
+import net.minecraft.world.level.biome.BiomeSource;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.border.WorldBorder;
+import net.minecraft.world.level.chunk.ChunkGenerator;
+import net.minecraft.world.level.dimension.DimensionType;
+import net.minecraft.world.level.dimension.LevelStem;
+import net.minecraft.world.level.levelgen.Heightmap;
+import net.minecraft.world.level.levelgen.NoiseBasedChunkGenerator;
+import net.minecraft.world.level.levelgen.PatrolSpawner;
+import net.minecraft.world.level.levelgen.PhantomSpawner;
+import net.minecraft.world.level.levelgen.WorldGenSettings;
+import net.minecraft.world.level.levelgen.feature.ConfiguredFeature;
+import net.minecraft.world.level.levelgen.structure.templatesystem.StructureManager;
+import net.minecraft.world.level.storage.CommandStorage;
+import net.minecraft.world.level.storage.DimensionDataStorage;
+import net.minecraft.world.level.storage.LevelData;
+import net.minecraft.world.level.storage.LevelResource;
+import net.minecraft.world.level.storage.LevelStorageSource;
+import net.minecraft.world.level.storage.PlayerDataStorage;
+import net.minecraft.world.level.storage.PrimaryLevelData;
+import net.minecraft.world.level.storage.ServerLevelData;
+import net.minecraft.world.level.storage.WorldData;
+import net.minecraft.world.level.storage.loot.ItemModifierManager;
+import net.minecraft.world.level.storage.loot.LootTables;
+import net.minecraft.world.level.storage.loot.PredicateManager;
+import net.minecraft.world.phys.Vec2;
+import net.minecraft.world.phys.Vec3;
+import net.minecraft.world.scores.PlayerTeam; // Paper
+import org.apache.commons.lang3.Validate;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+// CraftBukkit start
+import com.mojang.serialization.DynamicOps;
+import com.mojang.serialization.Lifecycle;
+import com.google.common.collect.ImmutableSet;
+// import jline.console.ConsoleReader; // Paper
+import joptsimple.OptionSet;
+import net.minecraft.resources.RegistryReadOps;
+import net.minecraft.server.bossevents.CustomBossEvents;
+import net.minecraft.server.dedicated.DedicatedServer;
+import net.minecraft.server.dedicated.DedicatedServerProperties;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.Main;
+import org.bukkit.craftbukkit.generator.CustomWorldChunkManager;
+import org.bukkit.event.server.ServerLoadEvent;
+// CraftBukkit end
+
+import co.aikar.timings.MinecraftTimings; // Paper
+import org.spigotmc.SlackActivityAccountant; // Spigot
+
+public abstract class MinecraftServer extends ReentrantBlockableEventLoop<Runnable> implements CommandSource, AutoCloseable {
+
+    private static MinecraftServer SERVER; // Paper
+    public static final Logger LOGGER = LogManager.getLogger();
+    private static final float AVERAGE_TICK_TIME_SMOOTHING = 0.8F;
+    private static final int TICK_STATS_SPAN = 100;
+    public static final int MS_PER_TICK = 50;
+    // private static final int SNOOPER_UPDATE_INTERVAL = 6000;
+    private static final int OVERLOADED_THRESHOLD = 2000;
+    private static final int OVERLOADED_WARNING_INTERVAL = 15000;
+    public static final String LEVEL_STORAGE_PROTOCOL = "level";
+    public static final String LEVEL_STORAGE_SCHEMA = "level://";
+    private static final long STATUS_EXPIRE_TIME_NS = 5000000000L;
+    private static final int MAX_STATUS_PLAYER_SAMPLE = 12;
+    public static final String MAP_RESOURCE_FILE = "resources.zip";
+    public static final File USERID_CACHE_FILE = new File("usercache.json");
+    public static final int START_CHUNK_RADIUS = 11;
+    private static final int START_TICKING_CHUNK_COUNT = 441;
+    private static final int AUTOSAVE_INTERVAL = 6000;
+    private static final int MAX_TICK_LATENCY = 3;
+    public static final int ABSOLUTE_MAX_WORLD_SIZE = 29999984;
+    public static final LevelSettings DEMO_SETTINGS = new LevelSettings("Demo World", GameType.SURVIVAL, false, Difficulty.NORMAL, false, new GameRules(), DataPackConfig.DEFAULT);
+    private static final long DELAYED_TASKS_TICK_EXTENSION = 50L;
+    public LevelStorageSource.LevelStorageAccess storageSource;
+    public final PlayerDataStorage playerDataStorage;
+    // private final Snooper snooper = new Snooper("server", this, Util.getMillis());
+    private final List<Runnable> tickables = Lists.newArrayList();
+    private MetricsRecorder metricsRecorder;
+    private ProfilerFiller profiler;
+    private Consumer<ProfileResults> onMetricsRecordingStopped;
+    private Consumer<Path> onMetricsRecordingFinished;
+    private boolean willStartRecordingMetrics;
+    @Nullable
+    private MinecraftServer.TimeProfiler debugCommandProfiler;
+    private boolean debugCommandProfilerDelayStart;
+    private ServerConnectionListener connection;
+    public final ChunkProgressListenerFactory progressListenerFactory;
+    private final ServerStatus status;
+    private final Random random;
+    public final DataFixer fixerUpper;
+    private String localIp;
+    private int port;
+    public final RegistryAccess.RegistryHolder registryHolder;
+    public final Map<ResourceKey<Level>, ServerLevel> levels;
+    private PlayerList playerList;
+    private volatile boolean running;
+    private volatile boolean isRestarting = false; // Paper - flag to signify we're attempting to restart
+    private boolean stopped;
+    private int tickCount;
+    protected final Proxy proxy;
+    private boolean onlineMode;
+    private boolean preventProxyConnections;
+    private boolean pvp;
+    private boolean allowFlight;
+    @Nullable
+    private String motd;
+    private int playerIdleTimeout;
+    public final long[] tickTimes;
+    // Paper start
+    public final TickTimes tickTimes5s = new TickTimes(100);
+    public final TickTimes tickTimes10s = new TickTimes(200);
+    public final TickTimes tickTimes60s = new TickTimes(1200);
+    // Paper end
+    @Nullable
+    private KeyPair keyPair;
+    @Nullable
+    private String singleplayerName;
+    private boolean isDemo;
+    private String resourcePack;
+    private String resourcePackHash;
+    private volatile boolean isReady;
+    private long lastOverloadWarning;
+    private final MinecraftSessionService sessionService;
+    @Nullable
+    private final GameProfileRepository profileRepository;
+    @Nullable
+    private final GameProfileCache profileCache;
+    private long lastServerStatus;
+    public final Thread serverThread;
+    private long nextTickTime;
+    private long delayedTasksMaxNextTickTime;
+    private boolean mayHaveDelayedTasks;
+    private final PackRepository packRepository;
+    private final ServerScoreboard scoreboard;
+    @Nullable
+    private CommandStorage commandStorage;
+    private final CustomBossEvents customBossEvents;
+    private final ServerFunctionManager functionManager;
+    private final FrameTimer frameTimer;
+    private boolean enforceWhitelist;
+    private float averageTickTime;
+    public final Executor executor;
+    @Nullable
+    private String serverId;
+    public ServerResources resources;
+    private final StructureManager structureManager;
+    protected WorldData worldData;
+
+    // CraftBukkit start
+    public DataPackConfig datapackconfiguration;
+    public org.bukkit.craftbukkit.CraftServer server;
+    public OptionSet options;
+    public org.bukkit.command.ConsoleCommandSender console;
+    public org.bukkit.command.RemoteConsoleCommandSender remoteConsole;
+    //public ConsoleReader reader; // Paper
+    public static int currentTick = 0; // Paper - Further improve tick loop
+    public java.util.Queue<Runnable> processQueue = new java.util.concurrent.ConcurrentLinkedQueue<Runnable>();
+    public int autosavePeriod;
+    public boolean serverAutoSave = false; // Paper
+    public Commands vanillaCommandDispatcher;
+    public boolean forceTicks; // Paper
+    // CraftBukkit end
+    // Spigot start
+    public static final int TPS = 20;
+    public static final int TICK_TIME = 1000000000 / MinecraftServer.TPS;
+    private static final int SAMPLE_INTERVAL = 20; // Paper
+    public final double[] recentTps = new double[ 3 ];
+    public boolean lagging = false; // Purpur
+    public final SlackActivityAccountant slackActivityAccountant = new SlackActivityAccountant();
+    // Spigot end
+    public static long currentTickLong = 0L; // Paper
+
+    public volatile Thread shutdownThread; // Paper
+    public volatile boolean abnormalExit = false; // Paper
+    
+    public gg.pufferfish.pufferfish.util.AsyncExecutor mobSpawnExecutor = new gg.pufferfish.pufferfish.util.AsyncExecutor("MobSpawning", () -> true); // Pufferfish - optimize mob spawning
+
+    public static <S extends MinecraftServer> S spin(Function<Thread, S> serverFactory) {
+        AtomicReference<S> atomicreference = new AtomicReference();
+        Thread thread = new Thread(() -> {
+            ((MinecraftServer) atomicreference.get()).runServer();
+        }, "Server thread");
+
+        thread.setUncaughtExceptionHandler((thread1, throwable) -> {
+            MinecraftServer.LOGGER.error(throwable);
+        });
+        S s0 = serverFactory.apply(thread); // CraftBukkit - decompile error
+
+        atomicreference.set(s0);
+        thread.setPriority(Thread.NORM_PRIORITY+2); // Paper - boost priority
+        thread.start();
+        return s0;
+    }
+
+    // Paper start - execute chunk tasks mid tick
+    static final long CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME = 25L * 1000L; // 25us
+    static final long MAX_CHUNK_EXEC_TIME = 1000L; // 1us
+
+    static final long TASK_EXECUTION_FAILURE_BACKOFF = 5L * 1000L; // 5us
+
+    private static long lastMidTickExecute;
+    private static long lastMidTickExecuteFailure;
+
+    private boolean tickMidTickTasks() {
+        // give all worlds a fair chance at by targetting them all.
+        // if we execute too many tasks, that's fine - we have logic to correctly handle overuse of allocated time.
+        boolean executed = false;
+        for (ServerLevel world : this.getAllLevels()) {
+            long currTime = System.nanoTime();
+            if (currTime - world.lastMidTickExecuteFailure <= TASK_EXECUTION_FAILURE_BACKOFF) {
+                continue;
+            }
+            if (!world.getChunkSource().pollTask()) {
+                // we need to back off if this fails
+                world.lastMidTickExecuteFailure = currTime;
+            } else {
+                executed = true;
+            }
+        }
+
+        return executed;
+    }
+
+    public final void executeMidTickTasks() {
+        org.spigotmc.AsyncCatcher.catchOp("mid tick chunk task execution");
+        long startTime = System.nanoTime();
+        if ((startTime - lastMidTickExecute) <= CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME || (startTime - lastMidTickExecuteFailure) <= TASK_EXECUTION_FAILURE_BACKOFF) {
+            // it's shown to be bad to constantly hit the queue (chunk loads slow to a crawl), even if no tasks are executed.
+            // so, backoff to prevent this
+            return;
+        }
+
+        MCUtil.flushAsyncTasksMidTick();
+        co.aikar.timings.MinecraftTimings.midTickChunkTasks.startTiming();
+        try {
+            for (;;) {
+                boolean moreTasks = this.tickMidTickTasks();
+                long currTime = System.nanoTime();
+                long diff = currTime - startTime;
+
+                if (!moreTasks || diff >= MAX_CHUNK_EXEC_TIME) {
+                    if (!moreTasks) {
+                        lastMidTickExecuteFailure = currTime;
+                    }
+
+                    // note: negative values reduce the time
+                    long overuse = diff - MAX_CHUNK_EXEC_TIME;
+                    if (overuse >= (10L * 1000L * 1000L)) { // 10ms
+                        // make sure something like a GC or dumb plugin doesn't screw us over...
+                        overuse = 10L * 1000L * 1000L; // 10ms
+                    }
+
+                    double overuseCount = (double)overuse/(double)MAX_CHUNK_EXEC_TIME;
+                    long extraSleep = (long)Math.round(overuseCount*CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME);
+
+                    lastMidTickExecute = currTime + extraSleep;
+                    return;
+                }
+            }
+        } finally {
+            co.aikar.timings.MinecraftTimings.midTickChunkTasks.stopTiming();
+        }
+    }
+    // Paper end - execute chunk tasks mid tick
+
+    public MinecraftServer(OptionSet options, DataPackConfig datapackconfiguration, Thread thread, RegistryAccess.RegistryHolder iregistrycustom_dimension, LevelStorageSource.LevelStorageAccess convertable_conversionsession, WorldData savedata, PackRepository resourcepackrepository, Proxy proxy, DataFixer datafixer, ServerResources datapackresources, @Nullable MinecraftSessionService minecraftsessionservice, @Nullable GameProfileRepository gameprofilerepository, @Nullable GameProfileCache usercache, ChunkProgressListenerFactory worldloadlistenerfactory) {
+        super("Server");
+        SERVER = this; // Paper - better singleton
+        this.metricsRecorder = InactiveMetricsRecorder.INSTANCE;
+        this.profiler = this.metricsRecorder.getProfiler();
+        this.onMetricsRecordingStopped = (methodprofilerresults) -> {
+            this.stopRecordingMetrics();
+        };
+        this.onMetricsRecordingFinished = (path) -> {
+        };
+        this.status = new ServerStatus();
+        this.random = new Random();
+        this.port = -1;
+        this.levels = Maps.newLinkedHashMap(); // CraftBukkit - keep order, k+v already use identity methods
+        this.running = true;
+        this.tickTimes = new long[100];
+        this.resourcePack = "";
+        this.resourcePackHash = "";
+        this.nextTickTime = Util.getMillis();
+        this.scoreboard = new ServerScoreboard(this);
+        this.customBossEvents = new CustomBossEvents();
+        this.frameTimer = new FrameTimer();
+        this.registryHolder = iregistrycustom_dimension;
+        this.worldData = savedata;
+        this.proxy = proxy;
+        this.packRepository = resourcepackrepository;
+        this.resources = datapackresources;
+        this.sessionService = minecraftsessionservice;
+        this.profileRepository = gameprofilerepository;
+        this.profileCache = usercache;
+        if (usercache != null) {
+            usercache.setExecutor((Executor) this);
+        }
+
+        // this.connection = new ServerConnection(this); // Spigot
+        this.progressListenerFactory = worldloadlistenerfactory;
+        this.storageSource = convertable_conversionsession;
+        this.playerDataStorage = convertable_conversionsession.createPlayerStorage();
+        this.fixerUpper = datafixer;
+        this.functionManager = new ServerFunctionManager(this, datapackresources.getFunctionLibrary());
+        this.structureManager = new StructureManager(datapackresources.getResourceManager(), convertable_conversionsession, datafixer);
+        this.serverThread = thread;
+        this.executor = Util.backgroundExecutor();
+        // CraftBukkit start
+        this.options = options;
+        this.datapackconfiguration = datapackconfiguration;
+        this.vanillaCommandDispatcher = datapackresources.commands; // CraftBukkit
+        // Paper start - Handled by TerminalConsoleAppender
+        // Try to see if we're actually running in a terminal, disable jline if not
+        /*
+        if (System.console() == null && System.getProperty("jline.terminal") == null) {
+            System.setProperty("jline.terminal", "jline.UnsupportedTerminal");
+            Main.useJline = false;
+        }
+
+        try {
+            this.reader = new ConsoleReader(System.in, System.out);
+            this.reader.setExpandEvents(false); // Avoid parsing exceptions for uncommonly used event designators
+        } catch (Throwable e) {
+            try {
+                // Try again with jline disabled for Windows users without C++ 2008 Redistributable
+                System.setProperty("jline.terminal", "jline.UnsupportedTerminal");
+                System.setProperty("user.language", "en");
+                Main.useJline = false;
+                this.reader = new ConsoleReader(System.in, System.out);
+                this.reader.setExpandEvents(false);
+            } catch (IOException ex) {
+                MinecraftServer.LOGGER.warn((String) null, ex);
+            }
+        }
+        */
+        // Paper end
+        Runtime.getRuntime().addShutdownHook(new org.bukkit.craftbukkit.util.ServerShutdownThread(this));
+    }
+    // CraftBukkit end
+
+    private void readScoreboard(DimensionDataStorage persistentStateManager) {
+        ServerScoreboard scoreboardserver = this.getScoreboard();
+
+        Objects.requireNonNull(scoreboardserver);
+        Function<net.minecraft.nbt.CompoundTag, net.minecraft.world.scores.ScoreboardSaveData> function = scoreboardserver::createData; // CraftBukkit - decompile error
+        ServerScoreboard scoreboardserver1 = this.getScoreboard();
+
+        Objects.requireNonNull(scoreboardserver1);
+        persistentStateManager.computeIfAbsent(function, scoreboardserver1::createData, "scoreboard");
+    }
+
+    protected abstract boolean initServer() throws IOException;
+
+    public static void convertFromRegionFormatIfNeeded(LevelStorageSource.LevelStorageAccess session) {
+        if (session.requiresConversion()) {
+            MinecraftServer.LOGGER.info("Converting map! {}", session.getLevelId()); // CraftBukkit
+            session.convertLevel(new ProgressListener() {
+                private long timeStamp = Util.getMillis();
+
+                @Override
+                public void progressStartNoAbort(Component title) {}
+
+                @Override
+                public void progressStart(Component title) {}
+
+                @Override
+                public void progressStagePercentage(int percentage) {
+                    if (Util.getMillis() - this.timeStamp >= 1000L) {
+                        this.timeStamp = Util.getMillis();
+                        MinecraftServer.LOGGER.info("Converting... {}%", percentage);
+                    }
+
+                }
+
+                @Override
+                public void stop() {}
+
+                @Override
+                public void progressStage(Component task) {}
+            });
+        }
+
+    }
+
+    protected void loadWorld(String s) {
+        // CraftBukkit start
+        LevelStorageSource.LevelStorageAccess worldSession = this.storageSource;
+        RegistryAccess.RegistryHolder iregistrycustom_dimension = this.registryHolder;
+        RegistryReadOps<Tag> registryreadops = RegistryReadOps.createAndLoad((DynamicOps) NbtOps.INSTANCE, this.resources.getResourceManager(), (RegistryAccess) iregistrycustom_dimension);
+        PrimaryLevelData overworldData = (PrimaryLevelData) worldSession.getDataTag((DynamicOps) registryreadops, datapackconfiguration);
+        if (overworldData == null) {
+            LevelSettings worldsettings;
+            WorldGenSettings generatorsettings;
+
+            if (this.isDemo()) {
+                worldsettings = MinecraftServer.DEMO_SETTINGS;
+                generatorsettings = WorldGenSettings.demoSettings((RegistryAccess) iregistrycustom_dimension);
+            } else {
+                DedicatedServerProperties dedicatedserverproperties = ((DedicatedServer) this).getProperties();
+
+                worldsettings = new LevelSettings(dedicatedserverproperties.levelName, dedicatedserverproperties.gamemode, dedicatedserverproperties.hardcore, dedicatedserverproperties.difficulty, false, new GameRules(), this.datapackconfiguration);
+                generatorsettings = this.options.has("bonusChest") ? dedicatedserverproperties.getWorldGenSettings((RegistryAccess) iregistrycustom_dimension).withBonusChest() : dedicatedserverproperties.getWorldGenSettings((RegistryAccess) iregistrycustom_dimension);
+            }
+
+            overworldData = new PrimaryLevelData(worldsettings, generatorsettings, Lifecycle.stable());
+        }
+
+        WorldGenSettings overworldSettings = overworldData.worldGenSettings();
+        MappedRegistry<LevelStem> registrymaterials = overworldSettings.dimensions();
+        for (Entry<ResourceKey<LevelStem>, LevelStem> entry : registrymaterials.entrySet()) {
+            ResourceKey<LevelStem> dimensionKey = entry.getKey();
+
+            ServerLevel world;
+            int dimension = 0;
+
+            if (dimensionKey == LevelStem.NETHER) {
+                if (this.isNetherEnabled()) {
+                    dimension = -1;
+                } else {
+                    continue;
+                }
+            } else if (dimensionKey == LevelStem.END) {
+                if (this.server.getAllowEnd()) {
+                    dimension = 1;
+                } else {
+                    continue;
+                }
+            } else if (dimensionKey != LevelStem.OVERWORLD) {
+                dimension = -999;
+            }
+
+            String worldType = (dimension == -999) ? dimensionKey.location().getNamespace() + "_" + dimensionKey.location().getPath() : org.bukkit.World.Environment.getEnvironment(dimension).toString().toLowerCase();
+            String name = (dimensionKey == LevelStem.OVERWORLD) ? s : s + "_" + worldType;
+            if (dimension != 0) {
+                File newWorld = LevelStorageSource.getFolder(new File(name), dimensionKey);
+                File oldWorld = LevelStorageSource.getFolder(new File(s), dimensionKey);
+                File oldLevelDat = new File(new File(s), "level.dat"); // The data folders exist on first run as they are created in the PersistentCollection constructor above, but the level.dat won't
+
+                if (!newWorld.isDirectory() && oldWorld.isDirectory() && oldLevelDat.isFile()) {
+                    MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder required ----");
+                    MinecraftServer.LOGGER.info("Unfortunately due to the way that Minecraft implemented multiworld support in 1.6, Bukkit requires that you move your " + worldType + " folder to a new location in order to operate correctly.");
+                    MinecraftServer.LOGGER.info("We will move this folder for you, but it will mean that you need to move it back should you wish to stop using Bukkit in the future.");
+                    MinecraftServer.LOGGER.info("Attempting to move " + oldWorld + " to " + newWorld + "...");
+
+                    if (newWorld.exists()) {
+                        MinecraftServer.LOGGER.warn("A file or folder already exists at " + newWorld + "!");
+                        MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder failed ----");
+                    } else if (newWorld.getParentFile().mkdirs()) {
+                        if (oldWorld.renameTo(newWorld)) {
+                            MinecraftServer.LOGGER.info("Success! To restore " + worldType + " in the future, simply move " + newWorld + " to " + oldWorld);
+                            // Migrate world data too.
+                            try {
+                                com.google.common.io.Files.copy(oldLevelDat, new File(new File(name), "level.dat"));
+                                org.apache.commons.io.FileUtils.copyDirectory(new File(new File(s), "data"), new File(new File(name), "data"));
+                            } catch (IOException exception) {
+                                MinecraftServer.LOGGER.warn("Unable to migrate world data.");
+                            }
+                            MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder complete ----");
+                        } else {
+                            MinecraftServer.LOGGER.warn("Could not move folder " + oldWorld + " to " + newWorld + "!");
+                            MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder failed ----");
+                        }
+                    } else {
+                        MinecraftServer.LOGGER.warn("Could not create path for " + newWorld + "!");
+                        MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder failed ----");
+                    }
+                }
+
+                try {
+                    worldSession = LevelStorageSource.createDefault(this.server.getWorldContainer().toPath()).createAccess(name, dimensionKey);
+                } catch (IOException ex) {
+                    throw new RuntimeException(ex);
+                }
+                MinecraftServer.convertFromRegionFormatIfNeeded(worldSession); // Run conversion now
+            }
+
+            org.bukkit.generator.ChunkGenerator gen = this.server.getGenerator(name);
+            org.bukkit.generator.BiomeProvider biomeProvider = this.server.getBiomeProvider(name);
+
+            PrimaryLevelData worlddata = (PrimaryLevelData) worldSession.getDataTag((DynamicOps) registryreadops, datapackconfiguration);
+            if (worlddata == null) {
+                LevelSettings worldsettings;
+                WorldGenSettings generatorsettings;
+
+                if (this.isDemo()) {
+                    worldsettings = MinecraftServer.DEMO_SETTINGS;
+                    generatorsettings = WorldGenSettings.demoSettings((RegistryAccess) iregistrycustom_dimension);
+                } else {
+                    DedicatedServerProperties dedicatedserverproperties = ((DedicatedServer) this).getProperties();
+
+                    worldsettings = new LevelSettings(dedicatedserverproperties.levelName, dedicatedserverproperties.gamemode, dedicatedserverproperties.hardcore, dedicatedserverproperties.difficulty, false, new GameRules(), this.datapackconfiguration);
+                    generatorsettings = this.options.has("bonusChest") ? dedicatedserverproperties.getWorldGenSettings((RegistryAccess) iregistrycustom_dimension).withBonusChest() : dedicatedserverproperties.getWorldGenSettings((RegistryAccess) iregistrycustom_dimension);
+                }
+
+                worlddata = new PrimaryLevelData(worldsettings, generatorsettings, Lifecycle.stable());
+            }
+            worlddata.checkName(name); // CraftBukkit - Migration did not rewrite the level.dat; This forces 1.8 to take the last loaded world as respawn (in this case the end)
+            // Paper - move down
+
+            ServerLevelData iworlddataserver = worlddata;
+            WorldGenSettings generatorsettings = worlddata.worldGenSettings();
+            boolean flag = generatorsettings.isDebug();
+            long i = generatorsettings.seed();
+            long j = BiomeManager.obfuscateSeed(i);
+            List<CustomSpawner> list = ImmutableList.of(new PhantomSpawner(), new PatrolSpawner(), new CatSpawner(), new VillageSiege(), new WanderingTraderSpawner(iworlddataserver));
+            // Paper start - Use correct LevelStem registry
+            final LevelStem worlddimension;
+            if (dimensionKey == LevelStem.END || dimensionKey == LevelStem.NETHER) {
+                worlddimension = generatorsettings.dimensions().get(dimensionKey);
+            } else {
+                worlddimension = registrymaterials.get(dimensionKey);
+            }
+            // Paper end
+            DimensionType dimensionmanager;
+            ChunkGenerator chunkgenerator;
+
+            if (worlddimension == null) {
+                dimensionmanager = (DimensionType) this.registryHolder.registryOrThrow(Registry.DIMENSION_TYPE_REGISTRY).getOrThrow(DimensionType.OVERWORLD_LOCATION);
+                chunkgenerator = WorldGenSettings.makeDefaultOverworld(this.registryHolder.registryOrThrow(Registry.BIOME_REGISTRY), this.registryHolder.registryOrThrow(Registry.NOISE_GENERATOR_SETTINGS_REGISTRY), java.util.concurrent.ThreadLocalRandom.current().nextLong()); // Patina - don't create new random instance
+            } else {
+                dimensionmanager = worlddimension.type();
+                chunkgenerator = worlddimension.generator();
+            }
+
+            org.bukkit.generator.WorldInfo worldInfo = new org.bukkit.craftbukkit.generator.CraftWorldInfo(iworlddataserver, worldSession, org.bukkit.World.Environment.getEnvironment(dimension), dimensionmanager);
+            if (biomeProvider == null && gen != null) {
+                biomeProvider = gen.getDefaultBiomeProvider(worldInfo);
+            }
+
+            if (biomeProvider != null) {
+                BiomeSource worldChunkManager = new CustomWorldChunkManager(worldInfo, biomeProvider, this.registryHolder.ownedRegistryOrThrow(Registry.BIOME_REGISTRY));
+                if (chunkgenerator instanceof NoiseBasedChunkGenerator) {
+                    chunkgenerator = new NoiseBasedChunkGenerator(worldChunkManager, chunkgenerator.strongholdSeed, ((NoiseBasedChunkGenerator) chunkgenerator).settings);
+                }
+            }
+
+            // Paper start - fix and optimise world upgrading
+            if (options.has("forceUpgrade")) {
+                net.minecraft.server.Main.convertWorldButItWorks(
+                        dimensionKey, Level.getDimensionKey(dimensionmanager), worldSession, DataFixers.getDataFixer(), options.has("eraseCache")
+                );
+            }
+            // Paper end - fix and optimise world upgrading
+
+            ResourceKey<Level> worldKey = ResourceKey.create(Registry.DIMENSION_REGISTRY, dimensionKey.location());
+
+            if (dimensionKey == LevelStem.OVERWORLD) {
+                this.worldData = worlddata;
+                this.worldData.setGameType(((DedicatedServer) this).getProperties().gamemode); // From DedicatedServer.init
+
+                ChunkProgressListener worldloadlistener = this.progressListenerFactory.create(11);
+
+                world = new ServerLevel(this, this.executor, worldSession, iworlddataserver, worldKey, dimensionmanager, worldloadlistener, chunkgenerator, flag, j, list, true, org.bukkit.World.Environment.getEnvironment(dimension), gen, biomeProvider);
+                DimensionDataStorage worldpersistentdata = world.getDataStorage();
+                this.readScoreboard(worldpersistentdata);
+                this.server.scoreboardManager = new org.bukkit.craftbukkit.scoreboard.CraftScoreboardManager(this, world.getScoreboard());
+                this.commandStorage = new CommandStorage(worldpersistentdata);
+            } else {
+                ChunkProgressListener worldloadlistener = this.progressListenerFactory.create(11);
+                world = new ServerLevel(this, this.executor, worldSession, iworlddataserver, worldKey, dimensionmanager, worldloadlistener, chunkgenerator, flag, j, ImmutableList.of(), true, org.bukkit.World.Environment.getEnvironment(dimension), gen, biomeProvider);
+            }
+
+            worlddata.setModdedInfo(this.getServerModName(), this.getModdedStatus().isPresent());
+            this.initWorld(world, worlddata, worldData, worlddata.worldGenSettings());
+
+            this.levels.put(world.dimension(), world);
+            this.getPlayerList().setLevel(world);
+
+            if (worlddata.getCustomBossEvents() != null) {
+                this.getCustomBossEvents().load(worlddata.getCustomBossEvents());
+            }
+        }
+        this.forceDifficulty();
+        for (ServerLevel worldserver : this.getAllLevels()) {
+            worldserver.paperConfig.removeOldValues(); // Paper - callback for clearing old config options, after any migrations have taken place
+            this.loadSpawn(worldserver.getChunkSource().chunkMap.progressListener, worldserver);
+            worldserver.entityManager.tick(); // SPIGOT-6526: Load pending entities so they are available to the API
+            this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldLoadEvent(worldserver.getWorld()));
+        }
+
+        // Paper start - Handle collideRule team for player collision toggle
+        final ServerScoreboard scoreboard = this.getScoreboard();
+        final java.util.Collection<String> toRemove = scoreboard.getPlayerTeams().stream().filter(team -> team.getName().startsWith("collideRule_")).map(PlayerTeam::getName).collect(java.util.stream.Collectors.toList());
+        for (String teamName : toRemove) {
+            scoreboard.removePlayerTeam(scoreboard.getPlayerTeam(teamName)); // Clean up after ourselves
+        }
+
+        if (!com.destroystokyo.paper.PaperConfig.enablePlayerCollisions) {
+            this.getPlayerList().collideRuleTeamName = org.apache.commons.lang3.StringUtils.left("collideRule_" + java.util.concurrent.ThreadLocalRandom.current().nextInt(), 16);
+            PlayerTeam collideTeam = scoreboard.addPlayerTeam(this.getPlayerList().collideRuleTeamName);
+            collideTeam.setSeeFriendlyInvisibles(false); // Because we want to mimic them not being on a team at all
+        }
+        // Paper end
+
+        this.server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.POSTWORLD);
+        this.server.getPluginManager().callEvent(new ServerLoadEvent(ServerLoadEvent.LoadType.STARTUP));
+        this.connection.acceptConnections();
+        // CraftBukkit end
+    }
+
+    protected void forceDifficulty() {}
+
+    // CraftBukkit start
+    public void initWorld(ServerLevel worldserver, ServerLevelData iworlddataserver, WorldData saveData, WorldGenSettings generatorsettings) {
+        boolean flag = generatorsettings.isDebug();
+        // CraftBukkit start
+        if (worldserver.generator != null) {
+            worldserver.getWorld().getPopulators().addAll(worldserver.generator.getDefaultPopulators(worldserver.getWorld()));
+        }
+        WorldBorder worldborder = worldserver.getWorldBorder();
+
+        worldborder.applySettings(iworlddataserver.getWorldBorder());
+        this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldInitEvent(worldserver.getWorld())); // CraftBukkit - SPIGOT-5569
+        if (!iworlddataserver.isInitialized()) {
+            try {
+                MinecraftServer.setInitialSpawn(worldserver, iworlddataserver, generatorsettings.generateBonusChest(), flag);
+                iworlddataserver.setInitialized(true);
+                if (flag) {
+                    this.setupDebugLevel(this.worldData);
+                }
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.forThrowable(throwable, "Exception initializing level");
+
+                try {
+                    worldserver.fillReportDetails(crashreport);
+                } catch (Throwable throwable1) {
+                    ;
+                }
+
+                throw new ReportedException(crashreport);
+            }
+
+            iworlddataserver.setInitialized(true);
+        }
+    }
+    // CraftBukkit end
+
+    private static void setInitialSpawn(ServerLevel world, ServerLevelData worldProperties, boolean bonusChest, boolean debugWorld) {
+        if (debugWorld) {
+            worldProperties.setSpawn(BlockPos.ZERO.above(80), 0.0F);
+        } else {
+            ChunkGenerator chunkgenerator = world.getChunkSource().getGenerator();
+            // Paper start - moved down
+            // CraftBukkit start
+            if (world.generator != null) {
+                Random rand = new Random(world.getSeed());
+                org.bukkit.Location spawn = world.generator.getFixedSpawnLocation(world.getWorld(), rand);
+
+                if (spawn != null) {
+                    if (spawn.getWorld() != world.getWorld()) {
+                        throw new IllegalStateException("Cannot set spawn point for " + worldProperties.getLevelName() + " to be in another world (" + spawn.getWorld().getName() + ")");
+                    } else {
+                        worldProperties.setSpawn(new BlockPos(spawn.getBlockX(), spawn.getBlockY(), spawn.getBlockZ()), spawn.getYaw());
+                        return;
+                    }
+                }
+            }
+            // CraftBukkit end
+            // Paper start - if the generator created a spawn for us, then there is no need for us to also create a spawn -
+            // only do it if the generator did not
+            BiomeSource worldchunkmanager = chunkgenerator.getBiomeSource();
+            Random random = new Random(world.getSeed());
+            BlockPos blockposition = worldchunkmanager.findBiomeHorizontal(0, world.getSeaLevel(), 0, 256, (biomebase) -> {
+                return biomebase.getMobSettings().playerSpawnFriendly();
+            }, random);
+            ChunkPos chunkcoordintpair = blockposition == null ? new ChunkPos(0, 0) : new ChunkPos(blockposition);
+            // Paper end
+
+            if (blockposition == null) {
+                MinecraftServer.LOGGER.warn("Unable to find spawn biome");
+            }
+
+            boolean flag2 = false;
+            Iterator iterator = BlockTags.VALID_SPAWN.getValues().iterator();
+
+            while (iterator.hasNext()) {
+                Block block = (Block) iterator.next();
+
+                if (worldchunkmanager.getSurfaceBlocks().contains(block.defaultBlockState())) {
+                    flag2 = true;
+                    break;
+                }
+            }
+
+            int i = chunkgenerator.getSpawnHeight(world);
+
+            if (i < world.getMinBuildHeight()) {
+                BlockPos blockposition1 = chunkcoordintpair.getWorldPosition();
+
+                i = world.getHeight(Heightmap.Types.WORLD_SURFACE, blockposition1.getX() + 8, blockposition1.getZ() + 8);
+            }
+
+            worldProperties.setSpawn(chunkcoordintpair.getWorldPosition().offset(8, i, 8), 0.0F);
+            int j = 0;
+            int k = 0;
+            int l = 0;
+            int i1 = -1;
+            boolean flag3 = true;
+
+            for (int j1 = 0; j1 < 1024; ++j1) {
+                if (j > -16 && j <= 16 && k > -16 && k <= 16) {
+                    BlockPos blockposition2 = PlayerRespawnLogic.getSpawnPosInChunk(world, new ChunkPos(chunkcoordintpair.x + j, chunkcoordintpair.z + k), flag2);
+
+                    if (blockposition2 != null) {
+                        worldProperties.setSpawn(blockposition2, 0.0F);
+                        break;
+                    }
+                }
+
+                if (j == k || j < 0 && j == -k || j > 0 && j == 1 - k) {
+                    int k1 = l;
+
+                    l = -i1;
+                    i1 = k1;
+                }
+
+                j += l;
+                k += i1;
+            }
+
+            if (bonusChest) {
+                ConfiguredFeature<?, ?> worldgenfeatureconfigured = Features.BONUS_CHEST;
+
+                worldgenfeatureconfigured.place(world, chunkgenerator, world.random, new BlockPos(worldProperties.getXSpawn(), worldProperties.getYSpawn(), worldProperties.getZSpawn()));
+            }
+
+        }
+    }
+
+    private void setupDebugLevel(WorldData properties) {
+        properties.setDifficulty(Difficulty.PEACEFUL);
+        properties.setDifficultyLocked(true);
+        ServerLevelData iworlddataserver = properties.overworldData();
+
+        iworlddataserver.setRaining(false);
+        iworlddataserver.setThundering(false);
+        iworlddataserver.setClearWeatherTime(1000000000);
+        iworlddataserver.setDayTime(6000L);
+        iworlddataserver.setGameType(GameType.SPECTATOR);
+    }
+
+    // CraftBukkit start
+    public void loadSpawn(ChunkProgressListener worldloadlistener, ServerLevel worldserver) {
+        ServerChunkCache chunkproviderserver = worldserver.getChunkSource(); // Paper
+
+        // WorldServer worldserver = this.E();
+        this.forceTicks = true;
+        // CraftBukkit end
+        if (worldserver.getWorld().getKeepSpawnInMemory()) { // Paper
+
+        MinecraftServer.LOGGER.info("Preparing start region for dimension {}", worldserver.dimension().location());
+        BlockPos blockposition = worldserver.getSharedSpawnPos();
+
+        worldloadlistener.updateSpawnPos(new ChunkPos(blockposition));
+        //ChunkProviderServer chunkproviderserver = worldserver.getChunkProvider(); // Paper - move up
+
+        chunkproviderserver.getLightEngine().setTaskPerBatch(500);
+        this.nextTickTime = Util.getMillis();
+        // Paper start - configurable spawn reason
+        int radiusBlocks = worldserver.paperConfig.keepLoadedRange;
+        int radiusChunks = radiusBlocks / 16 + ((radiusBlocks & 15) != 0 ? 1 : 0);
+        int totalChunks = ((radiusChunks) * 2 + 1);
+        totalChunks *= totalChunks;
+        worldloadlistener.setChunkRadius(radiusBlocks / 16);
+
+        worldserver.addTicketsForSpawn(radiusBlocks, blockposition);
+        // Paper end
+
+        // CraftBukkit start
+        // this.nextTickTime = SystemUtils.getMonotonicMillis() + 10L;
+        this.executeModerately();
+        // Iterator iterator = this.worldServer.values().iterator();
+        }
+
+        if (true) {
+            ServerLevel worldserver1 = worldserver;
+            // CraftBukkit end
+            ForcedChunksSavedData forcedchunk = (ForcedChunksSavedData) worldserver1.getDataStorage().get(ForcedChunksSavedData::load, "chunks");
+
+            if (forcedchunk != null) {
+                LongIterator longiterator = forcedchunk.getChunks().iterator();
+
+                while (longiterator.hasNext()) {
+                    long i = longiterator.nextLong();
+                    ChunkPos chunkcoordintpair = new ChunkPos(i);
+
+                    worldserver1.getChunkSource().updateChunkForced(chunkcoordintpair, true);
+                }
+            }
+        }
+
+        // CraftBukkit start
+        // this.nextTick = SystemUtils.getMonotonicMillis() + 10L;
+        this.executeModerately();
+        // CraftBukkit end
+        if (worldserver.getWorld().getKeepSpawnInMemory()) worldloadlistener.stop(); // Paper
+        chunkproviderserver.getLightEngine().setTaskPerBatch(worldserver.paperConfig.lightQueueSize); // Paper - increase light queue size
+        // CraftBukkit start
+        // this.updateSpawnFlags();
+        worldserver.setSpawnSettings(worldserver.serverLevelData.getDifficulty() != Difficulty.PEACEFUL && ((DedicatedServer) this).settings.getProperties().spawnMonsters, this.isSpawningAnimals()); // Paper - per level difficulty (from setDifficulty(ServerLevel, Difficulty, boolean))
+
+        this.forceTicks = false;
+        // CraftBukkit end
+    }
+
+    protected void detectBundledResources() {
+        File file = this.storageSource.getLevelPath(LevelResource.MAP_RESOURCE_FILE).toFile();
+
+        if (file.isFile()) {
+            String s = this.storageSource.getLevelId();
+
+            try {
+                this.setResourcePack("level://" + URLEncoder.encode(s, StandardCharsets.UTF_8.toString()) + "/resources.zip", "");
+            } catch (UnsupportedEncodingException unsupportedencodingexception) {
+                MinecraftServer.LOGGER.warn("Something went wrong url encoding {}", s);
+            }
+        }
+
+    }
+
+    public GameType getDefaultGameType() {
+        return this.worldData.getGameType();
+    }
+
+    public boolean isHardcore() {
+        return this.worldData.isHardcore();
+    }
+
+    public abstract int getOperatorUserPermissionLevel();
+
+    public abstract int getFunctionCompilationLevel();
+
+    public abstract boolean shouldRconBroadcast();
+
+    public boolean saveAllChunks(boolean suppressLogs, boolean flush, boolean force) {
+        boolean flag3 = false;
+
+        for (Iterator iterator = this.getAllLevels().iterator(); iterator.hasNext(); flag3 = true) {
+            ServerLevel worldserver = (ServerLevel) iterator.next();
+
+            if (!suppressLogs) {
+                MinecraftServer.LOGGER.info("Saving chunks for level '{}'/{}", worldserver, worldserver.dimension().location());
+            }
+
+            worldserver.save((ProgressListener) null, flush, worldserver.noSave && !force);
+        }
+
+        // CraftBukkit start - moved to WorldServer.save
+        /*
+        WorldServer worldserver1 = this.E();
+        IWorldDataServer iworlddataserver = this.worldData.H();
+
+        iworlddataserver.a(worldserver1.getWorldBorder().t());
+        this.worldData.setCustomBossEvents(this.getBossBattleCustomData().save());
+        this.storageSource.a(this.registryHolder, this.worldData, this.getPlayerList().save());
+        */
+        // CraftBukkit end
+        if (flush) {
+            Iterator iterator1 = this.getAllLevels().iterator();
+
+            while (iterator1.hasNext()) {
+                ServerLevel worldserver2 = (ServerLevel) iterator1.next();
+
+                MinecraftServer.LOGGER.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", worldserver2.getChunkSource().chunkMap.getStorageName());
+            }
+
+            MinecraftServer.LOGGER.info("ThreadedAnvilChunkStorage: All dimensions are saved");
+        }
+
+        return flag3;
+    }
+
+    @Override
+    public void close() {
+        this.stopServer();
+    }
+
+    // CraftBukkit start
+    private boolean hasStopped = false;
+    public volatile boolean hasFullyShutdown = false; // Paper
+    private boolean hasLoggedStop = false; // Paper
+    private final Object stopLock = new Object();
+    public final boolean hasStopped() {
+        synchronized (this.stopLock) {
+            return this.hasStopped;
+        }
+    }
+    // CraftBukkit end
+
+    public void stopServer() {
+        // CraftBukkit start - prevent double stopping on multiple threads
+        synchronized(this.stopLock) {
+            if (this.hasStopped) return;
+            this.hasStopped = true;
+        }
+        if (!hasLoggedStop && isDebugging()) io.papermc.paper.util.TraceUtil.dumpTraceForThread("Server stopped"); // Paper
+        // Paper start - kill main thread, and kill it hard
+        shutdownThread = Thread.currentThread();
+        org.spigotmc.WatchdogThread.doStop(); // Paper
+        if (!isSameThread()) {
+            MinecraftServer.LOGGER.info("Stopping main thread (Ignore any thread death message you see! - DO NOT REPORT THREAD DEATH TO PAPER)");
+            while (this.getRunningThread().isAlive()) {
+                this.getRunningThread().stop();
+                try {
+                    Thread.sleep(1);
+                } catch (InterruptedException e) {}
+            }
+        }
+        // Paper end
+        // CraftBukkit end
+        MinecraftServer.LOGGER.info("Stopping server");
+        MinecraftTimings.stopServer(); // Paper
+        // CraftBukkit start
+        if (this.server != null) {
+            this.server.disablePlugins();
+            this.server.waitForAsyncTasksShutdown(); // Paper
+        }
+        // CraftBukkit end
+        if (this.getConnection() != null) {
+            this.getConnection().stop();
+        }
+
+        if (this.playerList != null) {
+            MinecraftServer.LOGGER.info("Saving players");
+            this.playerList.removeAll(this.isRestarting); // Paper
+            try { Thread.sleep(100); } catch (InterruptedException ex) {} // CraftBukkit - SPIGOT-625 - give server at least a chance to send packets
+        }
+
+        MinecraftServer.LOGGER.info("Saving worlds");
+        Iterator iterator = this.getAllLevels().iterator();
+
+        ServerLevel worldserver;
+
+        while (iterator.hasNext()) {
+            worldserver = (ServerLevel) iterator.next();
+            if (worldserver != null) {
+                worldserver.noSave = false;
+            }
+        }
+
+        this.saveAllChunks(false, true, false);
+        iterator = this.getAllLevels().iterator();
+
+        while (iterator.hasNext()) {
+            worldserver = (ServerLevel) iterator.next();
+            if (worldserver != null) {
+                try {
+                    worldserver.close();
+                } catch (IOException ioexception) {
+                    MinecraftServer.LOGGER.error("Exception closing the level", ioexception);
+                }
+            }
+        }
+
+        /*
+        if (this.snooper.isStarted()) {
+            this.snooper.interrupt();
+        }
+        */
+
+        this.resources.close();
+
+        try {
+            this.storageSource.close();
+        } catch (IOException ioexception1) {
+            MinecraftServer.LOGGER.error("Failed to unlock level {}", this.storageSource.getLevelId(), ioexception1);
+        }
+        // Spigot start
+        MCUtil.asyncExecutor.shutdown(); // Paper
+        this.playerDataStorage.executorService.shutdown(); // Yatopia
+        try { MCUtil.asyncExecutor.awaitTermination(30, java.util.concurrent.TimeUnit.SECONDS); // Paper
+            this.playerDataStorage.executorService.awaitTermination(30, java.util.concurrent.TimeUnit.SECONDS); // Yatopia - New async nbt cache
+        } catch (java.lang.InterruptedException ignored) {} // Paper
+        if (org.spigotmc.SpigotConfig.saveUserCacheOnStopOnly) {
+            MinecraftServer.LOGGER.info("Saving usercache.json");
+            this.getProfileCache().save(false); // Paper
+        }
+        // Spigot end
+        // Paper start - move final shutdown items here
+        LOGGER.info("Flushing Chunk IO");
+        com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.close(true, true); // Paper
+        LOGGER.info("Closing Thread Pool");
+        MCUtil.flushAsyncTasks();
+        Util.shutdownExecutors(); // Paper
+        LOGGER.info("Closing Server");
+        try {
+            net.minecrell.terminalconsole.TerminalConsoleAppender.close(); // Paper - Use TerminalConsoleAppender
+        } catch (Exception e) {
+        }
+        this.onServerExit();
+        // Paper end
+    }
+
+    public String getLocalIp() {
+        return this.localIp;
+    }
+
+    public void setLocalIp(String serverIp) {
+        this.localIp = serverIp;
+    }
+
+    public boolean isRunning() {
+        return this.running;
+    }
+
+    public void halt(boolean flag) {
+        // Paper start - allow passing of the intent to restart
+        this.safeShutdown(flag, false);
+    }
+    public void safeShutdown(boolean flag, boolean isRestarting) {
+        this.isRestarting = isRestarting;
+        this.hasLoggedStop = true; // Paper
+        if (isDebugging()) io.papermc.paper.util.TraceUtil.dumpTraceForThread("Server stopped"); // Paper
+        // Paper end
+        this.running = false;
+        if (flag) {
+            try {
+                this.serverThread.join();
+            } catch (InterruptedException interruptedexception) {
+                MinecraftServer.LOGGER.error("Error while shutting down", interruptedexception);
+            }
+        }
+
+    }
+
+    // Spigot Start
+    private static double calcTps(double avg, double exp, double tps)
+    {
+        return ( avg * exp ) + ( tps * ( 1 - exp ) );
+    }
+
+    // Paper start - Further improve server tick loop
+    private static final long SEC_IN_NANO = 1000000000;
+    private static final long MAX_CATCHUP_BUFFER = TICK_TIME * TPS * 60L;
+    private long lastTick = 0;
+    private long catchupTime = 0;
+    public final RollingAverage tps1 = new RollingAverage(60);
+    public final RollingAverage tps5 = new RollingAverage(60 * 5);
+    public final RollingAverage tps15 = new RollingAverage(60 * 15);
+
+    public static class RollingAverage {
+        private final int size;
+        private long time;
+        private java.math.BigDecimal total;
+        private int index = 0;
+        private final java.math.BigDecimal[] samples;
+        private final long[] times;
+
+        RollingAverage(int size) {
+            this.size = size;
+            this.time = size * SEC_IN_NANO;
+            this.total = dec(TPS).multiply(dec(SEC_IN_NANO)).multiply(dec(size));
+            this.samples = new java.math.BigDecimal[size];
+            this.times = new long[size];
+            for (int i = 0; i < size; i++) {
+                this.samples[i] = dec(TPS);
+                this.times[i] = SEC_IN_NANO;
+            }
+        }
+
+        private static java.math.BigDecimal dec(long t) {
+            return new java.math.BigDecimal(t);
+        }
+        public void add(java.math.BigDecimal x, long t) {
+            time -= times[index];
+            total = total.subtract(samples[index].multiply(dec(times[index])));
+            samples[index] = x;
+            times[index] = t;
+            time += t;
+            total = total.add(x.multiply(dec(t)));
+            if (++index == size) {
+                index = 0;
+            }
+        }
+
+        public double getAverage() {
+            return total.divide(dec(time), 30, java.math.RoundingMode.HALF_UP).doubleValue();
+        }
+    }
+    private static final java.math.BigDecimal TPS_BASE = new java.math.BigDecimal(1E9).multiply(new java.math.BigDecimal(SAMPLE_INTERVAL));
+    // Paper End
+    // Spigot End
+
+    protected void runServer() {
+        try {
+            long serverStartTime = Util.getNanos(); // Paper
+            if (this.initServer()) {
+                this.nextTickTime = Util.getMillis();
+                this.status.setDescription(new TextComponent(this.motd));
+                this.status.setVersion(new ServerStatus.Version(SharedConstants.getCurrentVersion().getName(), SharedConstants.getCurrentVersion().getProtocolVersion()));
+                this.updateStatusIcon(this.status);
+
+                // Spigot start
+                // Paper start - move done tracking
+                LOGGER.info("Running delayed init tasks");
+                this.server.getScheduler().mainThreadHeartbeat(this.tickCount); // run all 1 tick delay tasks during init,
+                // this is going to be the first thing the tick process does anyways, so move done and run it after
+                // everything is init before watchdog tick.
+                // anything at 3+ won't be caught here but also will trip watchdog....
+                // tasks are default scheduled at -1 + delay, and first tick will tick at 1
+                String doneTime = String.format(java.util.Locale.ROOT, "%.3fs", (double) (Util.getNanos() - serverStartTime) / 1.0E9D);
+                LOGGER.info("Done ({})! For help, type \"help\"", doneTime);
+                // Paper end
+
+                org.spigotmc.WatchdogThread.tick(); // Paper
+                org.spigotmc.WatchdogThread.hasStarted = true; // Paper
+                Arrays.fill( recentTps, 20 );
+                long start = System.nanoTime(), curTime, tickSection = start; // Paper - Further improve server tick loop
+                lastTick = start - TICK_TIME; // Paper
+                while (this.running) {
+                    long i = ((curTime = System.nanoTime()) / (1000L * 1000L)) - this.nextTickTime; // Paper
+
+                    if (i > 5000L && this.nextTickTime - this.lastOverloadWarning >= 30000L) { // CraftBukkit
+                        long j = i / 50L;
+
+                        if (this.server.getWarnOnOverload()) // CraftBukkit
+                            MinecraftServer.LOGGER.warn("Can't keep up! Is the server overloaded? Running {}ms or {} ticks behind", i, j);
+                        this.nextTickTime += j * 50L;
+                        this.lastOverloadWarning = this.nextTickTime;
+                    }
+
+                    ++MinecraftServer.currentTickLong; // Paper
+                    if ( ++MinecraftServer.currentTick % MinecraftServer.SAMPLE_INTERVAL == 0 )
+                    {
+                        final long diff = curTime - tickSection;
+                        java.math.BigDecimal currentTps = TPS_BASE.divide(new java.math.BigDecimal(diff), 30, java.math.RoundingMode.HALF_UP);
+                        tps1.add(currentTps, diff);
+                        tps5.add(currentTps, diff);
+                        tps15.add(currentTps, diff);
+                        // Backwards compat with bad plugins
+                        this.recentTps[0] = tps1.getAverage();
+                        this.recentTps[1] = tps5.getAverage();
+                        this.recentTps[2] = tps15.getAverage();
+                        // Paper end
+                        lagging = recentTps[0] < net.pl3x.purpur.PurpurConfig.laggingThreshold; // Purpur
+                        tickSection = curTime;
+                    }
+                    // Spigot end
+
+                    if (this.debugCommandProfilerDelayStart) {
+                        this.debugCommandProfilerDelayStart = false;
+                        this.debugCommandProfiler = new MinecraftServer.TimeProfiler(Util.getNanos(), this.tickCount);
+                    }
+
+                    //MinecraftServer.currentTick = (int) (System.currentTimeMillis() / 50); // CraftBukkit // Paper - don't overwrite current tick time
+                    lastTick = curTime;
+                    this.nextTickTime += 50L;
+                    this.startMetricsRecordingTick();
+                    this.profiler.push("tick");
+                    this.tickServer(this::haveTime);
+                    this.profiler.popPush("nextTickWait");
+                    this.mayHaveDelayedTasks = true;
+                    // Purpur start - tps catchup
+                    if (net.pl3x.purpur.PurpurConfig.tpsCatchup) {
+                        this.delayedTasksMaxNextTickTime = Math.max(Util.getMillis() + 50L, this.nextTickTime);
+                    } else {
+                        this.delayedTasksMaxNextTickTime = this.nextTickTime = curTime / 1000000L + 50L;
+                    }
+                    // Purpur end - tps catchup
+                    this.waitUntilNextTick();
+                    this.profiler.pop();
+                    this.endMetricsRecordingTick();
+                    this.isReady = true;
+                }
+            } else {
+                this.onServerCrash((CrashReport) null);
+            }
+        } catch (Throwable throwable) {
+            // Paper start
+            if (throwable instanceof ThreadDeath) {
+                MinecraftServer.LOGGER.error("Main thread terminated by WatchDog due to hard crash", throwable);
+                return;
+            }
+            // Paper end
+            MinecraftServer.LOGGER.error("Encountered an unexpected exception", throwable);
+            // Spigot Start
+            if ( throwable.getCause() != null )
+            {
+                MinecraftServer.LOGGER.error( "\tCause of unexpected exception was", throwable.getCause() );
+            }
+            // Spigot End
+            CrashReport crashreport;
+
+            if (throwable instanceof ReportedException) {
+                crashreport = ((ReportedException) throwable).getReport();
+            } else {
+                crashreport = new CrashReport("Exception in server tick loop", throwable);
+            }
+
+            this.fillSystemReport(crashreport.getSystemReport());
+            File file = new File(this.getServerDirectory(), "crash-reports");
+            SimpleDateFormat simpledateformat = new SimpleDateFormat("yyyy-MM-dd_HH.mm.ss");
+            Date date = new Date();
+            File file1 = new File(file, "crash-" + simpledateformat.format(date) + "-server.txt");
+
+            if (crashreport.saveToFile(file1)) {
+                MinecraftServer.LOGGER.error("This crash report has been saved to: {}", file1.getAbsolutePath());
+            } else {
+                MinecraftServer.LOGGER.error("We were unable to save this crash report to disk.");
+            }
+
+            this.onServerCrash(crashreport);
+        } finally {
+            try {
+                this.stopped = true;
+                this.stopServer();
+            } catch (Throwable throwable1) {
+                MinecraftServer.LOGGER.error("Exception stopping the server", throwable1);
+            } finally {
+                //org.spigotmc.WatchdogThread.doStop(); // Spigot // Paper - move into stop
+                // CraftBukkit start - Restore terminal to original settings
+                try {
+                    //net.minecrell.terminalconsole.TerminalConsoleAppender.close(); // Paper - Move into stop
+                } catch (Exception ignored) {
+                }
+                // CraftBukkit end
+                //this.exit(); // Paper - moved into stop
+            }
+
+        }
+
+    }
+
+    private boolean haveTime() {
+        // CraftBukkit start
+        if (isOversleep) return canOversleep();// Paper - because of our changes, this logic is broken
+        return this.forceTicks || this.runningTask() || Util.getMillis() < (this.mayHaveDelayedTasks ? this.delayedTasksMaxNextTickTime : this.nextTickTime);
+    }
+
+    // Paper start
+    boolean isOversleep = false;
+    private boolean canOversleep() {
+        return this.mayHaveDelayedTasks && Util.getMillis() < this.delayedTasksMaxNextTickTime;
+    }
+
+    private boolean canSleepForTickNoOversleep() {
+        return this.forceTicks || this.runningTask() || Util.getMillis() < this.nextTickTime;
+    }
+    // Paper end
+
+    private void executeModerately() {
+        this.runAllTasks();
+        java.util.concurrent.locks.LockSupport.parkNanos("executing tasks", 1000L);
+    }
+    // CraftBukkit end
+
+    protected void waitUntilNextTick() {
+        //this.executeAll(); // Paper - move this into the tick method for timings
+        this.managedBlock(() -> {
+            return !this.canSleepForTickNoOversleep(); // Paper - move oversleep into full server tick
+        });
+    }
+
+    @Override
+    public Runnable wrapRunnable(Runnable runnable) { // Patina
+        // Paper start - anything that does try to post to main during watchdog crash, run on watchdog
+        if (this.hasStopped && Thread.currentThread().equals(shutdownThread)) {
+            runnable.run();
+            runnable = () -> {};
+        }
+        // Paper end
+        return runnable; // Patina
+    }
+
+    /* // Patina
+    protected boolean shouldRun(TickTask ticktask) {
+        return ticktask.getTick() + 3 < this.tickCount || this.haveTime();
+    }
+    */
+
+    @Override
+    public boolean pollTask() {
+        boolean flag = this.pollTaskInternal();
+
+        this.mayHaveDelayedTasks = flag;
+        return flag;
+    }
+
+    private boolean pollTaskInternal() {
+        if (super.pollTask()) {
+            this.executeMidTickTasks(); // Paper - execute chunk tasks mid tick
+            return true;
+        } else {
+            if (this.haveTime()) {
+                Iterator iterator = this.getAllLevels().iterator();
+
+                while (iterator.hasNext()) {
+                    ServerLevel worldserver = (ServerLevel) iterator.next();
+
+                    if (worldserver.getChunkSource().pollTask()) {
+                        return true;
+                    }
+                }
+            }
+
+            return false;
+        }
+    }
+
+    /* // Patina
+    public void doRunTask(TickTask ticktask) {
+        this.getProfiler().incrementCounter("runTask");
+        super.doRunTask(ticktask);
+    }
+    */
+
+    private void updateStatusIcon(ServerStatus metadata) {
+        Optional<File> optional = Optional.of(this.getFile("server-icon.png")).filter(File::isFile);
+
+        if (!optional.isPresent()) {
+            optional = this.storageSource.getIconFile().map(Path::toFile).filter(File::isFile);
+        }
+
+        optional.ifPresent((file) -> {
+            try {
+                BufferedImage bufferedimage = ImageIO.read(file);
+
+                Validate.validState(bufferedimage.getWidth() == 64, "Must be 64 pixels wide", new Object[0]);
+                Validate.validState(bufferedimage.getHeight() == 64, "Must be 64 pixels high", new Object[0]);
+                ByteArrayOutputStream bytearrayoutputstream = new ByteArrayOutputStream();
+
+                ImageIO.write(bufferedimage, "PNG", bytearrayoutputstream);
+                byte[] abyte = Base64.getEncoder().encode(bytearrayoutputstream.toByteArray());
+                String s = new String(abyte, StandardCharsets.UTF_8);
+
+                metadata.setFavicon("data:image/png;base64," + s);
+            } catch (Exception exception) {
+                MinecraftServer.LOGGER.error("Couldn't load server icon", exception);
+            }
+
+        });
+    }
+
+    public Optional<Path> getWorldScreenshotFile() {
+        return this.storageSource.getIconFile();
+    }
+
+    public File getServerDirectory() {
+        return new File(".");
+    }
+
+    protected void onServerCrash(CrashReport report) {}
+
+    public void onServerExit() {}
+
+    public void tickServer(BooleanSupplier shouldKeepTicking) {
+        co.aikar.timings.TimingsManager.FULL_SERVER_TICK.startTiming(); // Paper
+        this.slackActivityAccountant.tickStarted(); // Spigot
+        long i = Util.getNanos();
+
+        // Paper start - move oversleep into full server tick
+        isOversleep = true;MinecraftTimings.serverOversleep.startTiming();
+        this.managedBlock(() -> {
+            return !this.canOversleep();
+        });
+        isOversleep = false;MinecraftTimings.serverOversleep.stopTiming();
+        // Paper end
+        new com.destroystokyo.paper.event.server.ServerTickStartEvent(this.tickCount+1).callEvent(); // Paper
+
+        ++this.tickCount;
+        this.tickChildren(shouldKeepTicking);
+        if (i - this.lastServerStatus >= 5000000000L) {
+            this.lastServerStatus = i;
+            this.status.setPlayers(new ServerStatus.Players(this.getMaxPlayers(), this.getPlayerCount()));
+            GameProfile[] agameprofile = new GameProfile[Math.min(this.getPlayerCount(), org.spigotmc.SpigotConfig.playerSample)]; // Paper
+            int j = Mth.nextInt(this.random, 0, this.getPlayerCount() - agameprofile.length);
+
+            for (int k = 0; k < agameprofile.length; ++k) {
+                agameprofile[k] = ((ServerPlayer) this.playerList.getPlayers().get(j + k)).getGameProfile();
+            }
+
+            Collections.shuffle(Arrays.asList(agameprofile));
+            this.status.getPlayers().setSample(agameprofile);
+        }
+
+        // if (this.autosavePeriod > 0 && this.tickCount % this.autosavePeriod == 0) { // CraftBukkit // Paper - move down
+        //     MinecraftServer.LOGGER.debug("Autosave started"); // Paper
+        serverAutoSave = (autosavePeriod > 0 && this.tickCount % autosavePeriod == 0); // Paper
+        // Paper start
+        int playerSaveInterval = com.destroystokyo.paper.PaperConfig.playerAutoSaveRate;
+        if (playerSaveInterval < 0) {
+            playerSaveInterval = autosavePeriod;
+        }
+        // Paper end
+            this.profiler.push("save");
+        if (playerSaveInterval > 0) { // Paper
+            this.playerList.savePlayers(playerSaveInterval); // Paper
+            // this.saveAllChunks(true, false, false); // Paper - saved incrementally below
+        } // Paper start
+        for (ServerLevel level : this.getAllLevels()) {
+            if (level.paperConfig.autoSavePeriod > 0) {
+                level.saveIncrementally(this.serverAutoSave);
+            }
+        }
+        // Paper end
+            this.profiler.pop();
+            // MinecraftServer.LOGGER.debug("Autosave finished"); // Paper
+        //} // Paper
+
+        /*
+        this.profiler.push("snooper");
+        if (((DedicatedServer) this).getProperties().snooperEnabled && !this.snooper.isStarted() && this.tickCount > 100) { // Spigot
+            this.snooper.start();
+        }
+
+        if (((DedicatedServer) this).getProperties().snooperEnabled && this.tickCount % 6000 == 0) { // Spigot
+            this.snooper.prepare();
+        }
+
+        io.papermc.paper.util.CachedLists.reset(); // Paper
+        this.profiler.pop();
+        */
+
+        // Paper start - move executeAll() into full server tick timing
+        try (co.aikar.timings.Timing ignored = MinecraftTimings.processTasksTimer.startTiming()) {
+            MCUtil.flushAsyncTasks();
+            this.runAllTasks();
+        }
+        // Paper end
+
+        // Paper start
+        long endTime = System.nanoTime();
+        long remaining = (TICK_TIME - (endTime - lastTick)) - catchupTime;
+        new com.destroystokyo.paper.event.server.ServerTickEndEvent(this.tickCount, ((double)(endTime - lastTick) / 1000000D), remaining).callEvent();
+        // Paper end
+
+        this.profiler.push("tallying");
+        long l = this.tickTimes[this.tickCount % 100] = Util.getNanos() - i;
+
+        this.averageTickTime = this.averageTickTime * 0.8F + (float) l / 1000000.0F * 0.19999999F;
+        long i1 = Util.getNanos();
+
+        // Paper start
+        tickTimes5s.add(this.tickCount, l);
+        tickTimes10s.add(this.tickCount, l);
+        tickTimes60s.add(this.tickCount, l);
+        // Paper end
+
+        this.frameTimer.logFrameDuration(i1 - i);
+        this.profiler.pop();
+        org.spigotmc.WatchdogThread.tick(); // Spigot
+        this.slackActivityAccountant.tickEnded(l); // Spigot
+        co.aikar.timings.TimingsManager.FULL_SERVER_TICK.stopTiming(); // Paper
+    }
+
+    public void tickChildren(BooleanSupplier shouldKeepTicking) {
+        MinecraftTimings.bukkitSchedulerTimer.startTiming(); // Spigot // Paper
+        this.server.getScheduler().mainThreadHeartbeat(this.tickCount); // CraftBukkit
+        MinecraftTimings.bukkitSchedulerTimer.stopTiming(); // Spigot // Paper
+        this.profiler.push("commandFunctions");
+        MinecraftTimings.commandFunctionsTimer.startTiming(); // Spigot // Paper
+        this.getFunctions().tick();
+        MinecraftTimings.commandFunctionsTimer.stopTiming(); // Spigot // Paper
+        this.profiler.popPush("levels");
+        Iterator iterator = this.getAllLevels().iterator();
+
+        // CraftBukkit start
+        // Run tasks that are waiting on processing
+        MinecraftTimings.processQueueTimer.startTiming(); // Spigot
+        while (!this.processQueue.isEmpty()) {
+            this.processQueue.remove().run();
+        }
+        MinecraftTimings.processQueueTimer.stopTiming(); // Spigot
+
+        MinecraftTimings.timeUpdateTimer.startTiming(); // Spigot // Paper
+        // Send time updates to everyone, it will get the right time from the world the player is in.
+        // Paper start - optimize time updates
+        for (final ServerLevel world : this.getAllLevels()) {
+            final boolean doDaylight = world.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT);
+            final long dayTime = world.getDayTime();
+            long worldTime = world.getGameTime();
+            final ClientboundSetTimePacket worldPacket = new ClientboundSetTimePacket(worldTime, dayTime, doDaylight);
+            for (Player entityhuman : world.players()) {
+                if (!(entityhuman instanceof ServerPlayer) || (tickCount + entityhuman.getId()) % 20 != 0) {
+                    continue;
+                }
+                ServerPlayer entityplayer = (ServerPlayer) entityhuman;
+                long playerTime = entityplayer.getPlayerTime();
+                ClientboundSetTimePacket packet = (playerTime == dayTime) ? worldPacket :
+                    new ClientboundSetTimePacket(worldTime, playerTime, doDaylight);
+                entityplayer.connection.send(packet); // Add support for per player time
+            }
+        }
+        // Paper end
+        MinecraftTimings.timeUpdateTimer.stopTiming(); // Spigot // Paper
+
+        while (iterator.hasNext()) {
+            ServerLevel worldserver = (ServerLevel) iterator.next();
+            worldserver.hasPhysicsEvent =  org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+            worldserver.hasEntityMoveEvent =  io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+            net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = worldserver.paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
+
+            this.profiler.push(() -> {
+                return worldserver + " " + worldserver.dimension().location();
+            });
+            /* Drop global time updates
+            if (this.tickCount % 20 == 0) {
+                this.profiler.enter("timeSync");
+                this.playerList.a((Packet) (new PacketPlayOutUpdateTime(worldserver.getTime(), worldserver.getDayTime(), worldserver.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT))), worldserver.getDimensionKey());
+                this.profiler.exit();
+            }
+            // CraftBukkit end */
+
+            this.profiler.push("tick");
+
+            try {
+                worldserver.timings.doTick.startTiming(); // Spigot
+                worldserver.tick(shouldKeepTicking);
+                // Paper start
+                for (final io.papermc.paper.chunk.SingleThreadChunkRegionManager regionManager : worldserver.getChunkSource().chunkMap.regionManagers) {
+                    regionManager.recalculateRegions();
+                }
+                // Paper end
+                worldserver.timings.doTick.stopTiming(); // Spigot
+            } catch (Throwable throwable) {
+                // Spigot Start
+                CrashReport crashreport;
+                try {
+                    crashreport = CrashReport.forThrowable(throwable, "Exception ticking world");
+                } catch (Throwable t) {
+                    if (throwable instanceof ThreadDeath) { throw (ThreadDeath)throwable; } // Paper
+                    throw new RuntimeException("Error generating crash report", t);
+                }
+                // Spigot End
+
+                worldserver.fillReportDetails(crashreport);
+                throw new ReportedException(crashreport);
+            }
+
+            this.profiler.pop();
+            this.profiler.pop();
+            worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
+        }
+
+        this.profiler.popPush("connection");
+        MinecraftTimings.connectionTimer.startTiming(); // Spigot
+        this.getConnection().tick();
+        MinecraftTimings.connectionTimer.stopTiming(); // Spigot
+        this.profiler.popPush("players");
+        MinecraftTimings.playerListTimer.startTiming(); // Spigot // Paper
+        this.playerList.tick();
+        MinecraftTimings.playerListTimer.stopTiming(); // Spigot // Paper
+        if (SharedConstants.IS_RUNNING_IN_IDE) {
+            GameTestTicker.SINGLETON.tick();
+        }
+
+        this.profiler.popPush("server gui refresh");
+
+        MinecraftTimings.tickablesTimer.startTiming(); // Spigot // Paper
+        for (int i = 0; i < this.tickables.size(); ++i) {
+            ((Runnable) this.tickables.get(i)).run();
+        }
+        MinecraftTimings.tickablesTimer.stopTiming(); // Spigot // Paper
+
+        this.profiler.pop();
+    }
+
+    public boolean isNetherEnabled() {
+        return true;
+    }
+
+    public void addTickable(Runnable tickable) {
+        this.tickables.add(tickable);
+    }
+
+    protected void setId(String serverId) {
+        this.serverId = serverId;
+    }
+
+    public boolean isShutdown() {
+        return !this.serverThread.isAlive();
+    }
+
+    public File getFile(String path) {
+        return new File(this.getServerDirectory(), path);
+    }
+
+    public final ServerLevel overworld() {
+        return (ServerLevel) this.levels.get(Level.OVERWORLD);
+    }
+
+    @Nullable
+    public ServerLevel getLevel(ResourceKey<Level> key) {
+        return (ServerLevel) this.levels.get(key);
+    }
+
+    public Set<ResourceKey<Level>> levelKeys() {
+        return this.levels.keySet();
+    }
+
+    public Iterable<ServerLevel> getAllLevels() {
+        return this.levels.values();
+    }
+
+    public String getServerVersion() {
+        return SharedConstants.getCurrentVersion().getName();
+    }
+
+    public int getPlayerCount() {
+        return this.playerList.getPlayerCount();
+    }
+
+    public int getMaxPlayers() {
+        return this.playerList.getMaxPlayers();
+    }
+
+    public String[] getPlayerNames() {
+        return this.playerList.getPlayerNamesArray();
+    }
+
+    @DontObfuscate
+    public String getServerModName() {
+        return "Fiadelity"; // Fiadelity // Airplane // Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+    }
+
+    public SystemReport fillSystemReport(SystemReport details) {
+        if (this.playerList != null) {
+            details.setDetail("Player Count", () -> {
+                int i = this.playerList.getPlayerCount();
+
+                return i + " / " + this.playerList.getMaxPlayers() + "; " + this.playerList.getPlayers();
+            });
+        }
+
+        details.setDetail("Data Packs", () -> {
+            StringBuilder stringbuilder = new StringBuilder();
+            Iterator iterator = this.packRepository.getSelectedPacks().iterator();
+
+            while (iterator.hasNext()) {
+                Pack resourcepackloader = (Pack) iterator.next();
+
+                if (stringbuilder.length() > 0) {
+                    stringbuilder.append(", ");
+                }
+
+                stringbuilder.append(resourcepackloader.getId());
+                if (!resourcepackloader.getCompatibility().isCompatible()) {
+                    stringbuilder.append(" (incompatible)");
+                }
+            }
+
+            return stringbuilder.toString();
+        });
+        if (this.serverId != null) {
+            details.setDetail("Server Id", () -> {
+                return this.serverId;
+            });
+        }
+
+        return this.fillServerSystemReport(details);
+    }
+
+    public abstract SystemReport fillServerSystemReport(SystemReport details);
+
+    public abstract Optional<String> getModdedStatus();
+
+    @Override
+    public void sendMessage(Component message, UUID sender) {
+        MinecraftServer.LOGGER.info(PaperAdventure.LEGACY_SECTION_UXRC.serialize(PaperAdventure.asAdventure(message))); // Paper - Log message with colors
+    }
+
+    public KeyPair getKeyPair() {
+        return this.keyPair;
+    }
+
+    public int getPort() {
+        return this.port;
+    }
+
+    public void setPort(int serverPort) {
+        this.port = serverPort;
+    }
+
+    public String getSingleplayerName() {
+        return this.singleplayerName;
+    }
+
+    public void setSingleplayerName(String serverName) {
+        this.singleplayerName = serverName;
+    }
+
+    public boolean isSingleplayer() {
+        return this.singleplayerName != null;
+    }
+
+    protected void initializeKeyPair() {
+        MinecraftServer.LOGGER.info("Generating keypair");
+
+        try {
+            this.keyPair = Crypt.generateKeyPair();
+        } catch (CryptException cryptographyexception) {
+            throw new IllegalStateException("Failed to generate key pair", cryptographyexception);
+        }
+    }
+
+    // Paper start - remember per level difficulty
+    public void setDifficulty(ServerLevel level, Difficulty difficulty, boolean forceUpdate) {
+        PrimaryLevelData worldData = level.serverLevelData;
+        if (forceUpdate || !worldData.isDifficultyLocked()) {
+            worldData.setDifficulty(worldData.isHardcore() ? Difficulty.HARD : difficulty);
+            level.setSpawnSettings(worldData.getDifficulty() != Difficulty.PEACEFUL && ((DedicatedServer) this).settings.getProperties().spawnMonsters, this.isSpawningAnimals());
+            // this.getPlayerList().getPlayers().forEach(this::sendDifficultyUpdate);
+            // Paper end
+        }
+    }
+
+    public int getScaledTrackingDistance(int initialDistance) {
+        return initialDistance;
+    }
+
+    private void updateMobSpawningFlags() {
+        Iterator iterator = this.getAllLevels().iterator();
+
+        while (iterator.hasNext()) {
+            ServerLevel worldserver = (ServerLevel) iterator.next();
+
+            worldserver.setSpawnSettings(worldserver.serverLevelData.getDifficulty() != Difficulty.PEACEFUL && ((DedicatedServer) this).settings.getProperties().spawnMonsters, this.isSpawningAnimals()); // Paper - per level difficulty (from setDifficulty(ServerLevel, Difficulty, boolean))
+        }
+
+    }
+
+    public void setDifficultyLocked(boolean locked) {
+        this.worldData.setDifficultyLocked(locked);
+        this.getPlayerList().getPlayers().forEach(this::sendDifficultyUpdate);
+    }
+
+    private void sendDifficultyUpdate(ServerPlayer player) {
+        LevelData worlddata = player.getLevel().getLevelData();
+
+        player.connection.send(new ClientboundChangeDifficultyPacket(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
+    }
+
+    public boolean isSpawningMonsters() {
+        return this.worldData.getDifficulty() != Difficulty.PEACEFUL;
+    }
+
+    public boolean isDemo() {
+        return this.isDemo;
+    }
+
+    public void setDemo(boolean demo) {
+        this.isDemo = demo;
+    }
+
+    public String getResourcePack() {
+        return this.resourcePack;
+    }
+
+    public String getResourcePackHash() {
+        return this.resourcePackHash;
+    }
+
+    public void setResourcePack(String url, String hash) {
+        this.resourcePack = url;
+        this.resourcePackHash = hash;
+    }
+
+    /*
+    @Override
+    public void populateSnooper(Snooper snooper) {
+        snooper.setDynamicData("whitelist_enabled", (Object) false);
+        snooper.setDynamicData("whitelist_count", (int) 0);
+        if (this.playerList != null) {
+            snooper.setDynamicData("players_current", (Object) this.getPlayerCount());
+            snooper.setDynamicData("players_max", (Object) this.getMaxPlayers());
+            snooper.setDynamicData("players_seen", (Object) this.playerDataStorage.getSeenPlayers().length);
+        }
+
+        snooper.setDynamicData("uses_auth", (Object) this.onlineMode);
+        snooper.setDynamicData("gui_state", (Object) (this.hasGui() ? "enabled" : "disabled"));
+        snooper.setDynamicData("run_time", (Object) ((Util.getMillis() - snooper.getStartupTime()) / 60L * 1000L));
+        snooper.setDynamicData("avg_tick_ms", (Object) ((int) (Mth.average(this.tickTimes) * 1.0E-6D)));
+        int i = 0;
+        Iterator iterator = this.getAllLevels().iterator();
+
+        while (iterator.hasNext()) {
+            ServerLevel worldserver = (ServerLevel) iterator.next();
+
+            if (worldserver != null) {
+                snooper.setDynamicData("world[" + i + "][dimension]", (Object) worldserver.dimension().location());
+                snooper.setDynamicData("world[" + i + "][mode]", (Object) this.worldData.getGameType());
+                snooper.setDynamicData("world[" + i + "][difficulty]", (Object) worldserver.getDifficulty());
+                snooper.setDynamicData("world[" + i + "][hardcore]", (Object) this.worldData.isHardcore());
+                snooper.setDynamicData("world[" + i + "][height]", (Object) worldserver.getMaxBuildHeight());
+                snooper.setDynamicData("world[" + i + "][chunks_loaded]", (Object) worldserver.getChunkSource().getLoadedChunksCount());
+                ++i;
+            }
+        }
+
+        snooper.setDynamicData("worlds", (Object) i);
+    }
+
+    @Override
+    public void populateSnooperInitial(Snooper snooper) {
+        snooper.setFixedData("singleplayer", this.isSingleplayer());
+        snooper.setFixedData("server_brand", this.getServerModName());
+        snooper.setFixedData("gui_supported", GraphicsEnvironment.isHeadless() ? "headless" : "supported");
+        snooper.setFixedData("dedicated", this.isDedicatedServer());
+    }
+
+    @Override
+    public boolean isSnooperEnabled() {
+        return false;
+    }
+    */
+
+    public abstract boolean isDedicatedServer();
+
+    public abstract int getRateLimitPacketsPerSecond();
+
+    public boolean usesAuthentication() {
+        return this.onlineMode;
+    }
+
+    public void setUsesAuthentication(boolean onlineMode) {
+        this.onlineMode = onlineMode;
+    }
+
+    public boolean getPreventProxyConnections() {
+        return this.preventProxyConnections;
+    }
+
+    public void setPreventProxyConnections(boolean preventProxyConnections) {
+        this.preventProxyConnections = preventProxyConnections;
+    }
+
+    public boolean isSpawningAnimals() {
+        return true;
+    }
+
+    public boolean areNpcsEnabled() {
+        return true;
+    }
+
+    public abstract boolean isEpollEnabled();
+
+    public boolean isPvpAllowed() {
+        return this.pvp;
+    }
+
+    public void setPvpAllowed(boolean pvpEnabled) {
+        this.pvp = pvpEnabled;
+    }
+
+    public boolean isFlightAllowed() {
+        return this.allowFlight;
+    }
+
+    public void setFlightAllowed(boolean flightEnabled) {
+        this.allowFlight = flightEnabled;
+    }
+
+    public abstract boolean isCommandBlockEnabled();
+
+    public String getMotd() {
+        return this.motd;
+    }
+
+    public void setMotd(String motd) {
+        this.motd = motd;
+    }
+
+    public boolean isStopped() {
+        return this.stopped;
+    }
+
+    public PlayerList getPlayerList() {
+        return this.playerList;
+    }
+
+    public void setPlayerList(PlayerList playerManager) {
+        this.playerList = playerManager;
+    }
+
+    public abstract boolean isPublished();
+
+    public void setDefaultGameType(GameType gameMode) {
+        this.worldData.setGameType(gameMode);
+    }
+
+    @Nullable
+    public ServerConnectionListener getConnection() {
+        return this.connection == null ? this.connection = new ServerConnectionListener(this) : this.connection; // Spigot
+    }
+
+    public boolean isReady() {
+        return this.isReady;
+    }
+
+    public boolean hasGui() {
+        return false;
+    }
+
+    public boolean publishServer(@Nullable GameType gameMode, boolean cheatsAllowed, int port) {
+        return false;
+    }
+
+    public int getTickCount() {
+        return this.tickCount;
+    }
+
+    /*
+    public Snooper getSnooper() {
+        return this.snooper;
+    }
+    */
+
+    public int getSpawnProtectionRadius() {
+        return 16;
+    }
+
+    public boolean isUnderSpawnProtection(ServerLevel world, BlockPos pos, Player player) {
+        return false;
+    }
+
+    public boolean repliesToStatus() {
+        return true;
+    }
+
+    public Proxy getProxy() {
+        return this.proxy;
+    }
+
+    public int getPlayerIdleTimeout() {
+        return this.playerIdleTimeout;
+    }
+
+    public void setPlayerIdleTimeout(int playerIdleTimeout) {
+        this.playerIdleTimeout = playerIdleTimeout;
+    }
+
+    public MinecraftSessionService getSessionService() {
+        return this.sessionService;
+    }
+
+    public GameProfileRepository getProfileRepository() {
+        return this.profileRepository;
+    }
+
+    public GameProfileCache getProfileCache() {
+        return this.profileCache;
+    }
+
+    public ServerStatus getStatus() {
+        return this.status;
+    }
+
+    public void invalidateStatus() {
+        this.lastServerStatus = 0L;
+    }
+
+    public int getAbsoluteMaxWorldSize() {
+        return 29999984;
+    }
+
+    @Override
+    public boolean scheduleExecutables() {
+        return super.scheduleExecutables() && !this.isStopped();
+    }
+
+    @Override
+    public Thread getRunningThread() {
+        return this.serverThread;
+    }
+
+    public int getCompressionThreshold() {
+        return 256;
+    }
+
+    public long getNextTickTime() {
+        return this.nextTickTime;
+    }
+
+    public DataFixer getFixerUpper() {
+        return this.fixerUpper;
+    }
+
+    public int getSpawnRadius(@Nullable ServerLevel world) {
+        return world != null ? world.getGameRules().getInt(GameRules.RULE_SPAWN_RADIUS) : 10;
+    }
+
+    public ServerAdvancementManager getAdvancements() {
+        return this.resources.getAdvancements();
+    }
+
+    public ServerFunctionManager getFunctions() {
+        return this.functionManager;
+    }
+
+    // Paper start - add cause
+    @Deprecated
+    public CompletableFuture<Void> reloadResources(Collection<String> datapacks) {
+        return this.reloadResources(datapacks, io.papermc.paper.event.server.ServerResourcesReloadedEvent.Cause.PLUGIN);
+    }
+    public CompletableFuture<Void> reloadResources(Collection<String> datapacks, io.papermc.paper.event.server.ServerResourcesReloadedEvent.Cause cause) {
+        // Paper end
+        CompletableFuture<Void> completablefuture = CompletableFuture.supplyAsync(() -> {
+            Stream<String> stream = datapacks.stream(); // CraftBukkit - decompile error
+            PackRepository resourcepackrepository = this.packRepository;
+
+            Objects.requireNonNull(this.packRepository);
+            return stream.<Pack>map(resourcepackrepository::getPack).filter(Objects::nonNull).map(Pack::open).collect(ImmutableList.toImmutableList()); // CraftBukkit - decompile error // Paper - decompile error
+        }, this).thenCompose((immutablelist) -> {
+            return ServerResources.loadResources(immutablelist, this.registryHolder, this.isDedicatedServer() ? Commands.CommandSelection.DEDICATED : Commands.CommandSelection.INTEGRATED, this.getFunctionCompilationLevel(), this.executor, this);
+        }).thenAcceptAsync((datapackresources) -> {
+            this.resources.close();
+            this.resources = datapackresources;
+            this.server.syncCommands(); // SPIGOT-5884: Lost on reload
+            this.packRepository.setSelected(datapacks);
+            this.worldData.setDataPackConfig(MinecraftServer.getSelectedPacks(this.packRepository));
+            datapackresources.updateGlobals();
+            new io.papermc.paper.event.server.ServerResourcesReloadedEvent(cause).callEvent(); // Paper
+            if (Thread.currentThread() != this.serverThread) return; // Paper
+            //this.getPlayerList().savePlayers(); // Paper - we don't need to do this
+            this.getPlayerList().reloadResources();
+            this.functionManager.replaceLibrary(this.resources.getFunctionLibrary());
+            this.structureManager.onResourceManagerReload(this.resources.getResourceManager());
+            org.bukkit.craftbukkit.block.data.CraftBlockData.reloadCache(); // Paper - cache block data strings, they can be defined by datapacks so refresh it here
+        }, this);
+
+        if (this.isSameThread()) {
+            Objects.requireNonNull(completablefuture);
+            this.managedBlock(completablefuture::isDone);
+        }
+
+        return completablefuture;
+    }
+
+    public static DataPackConfig configurePackRepository(PackRepository resourcePackManager, DataPackConfig dataPackSettings, boolean safeMode) {
+        resourcePackManager.reload();
+        if (safeMode) {
+            resourcePackManager.setSelected((Collection) Collections.singleton("vanilla"));
+            return new DataPackConfig(ImmutableList.of("vanilla"), ImmutableList.of());
+        } else {
+            Set<String> set = Sets.newLinkedHashSet();
+            Iterator iterator = dataPackSettings.getEnabled().iterator();
+
+            while (iterator.hasNext()) {
+                String s = (String) iterator.next();
+
+                if (resourcePackManager.isAvailable(s)) {
+                    set.add(s);
+                } else {
+                    MinecraftServer.LOGGER.warn("Missing data pack {}", s);
+                }
+            }
+
+            iterator = resourcePackManager.getAvailablePacks().iterator();
+
+            while (iterator.hasNext()) {
+                Pack resourcepackloader = (Pack) iterator.next();
+                String s1 = resourcepackloader.getId();
+
+                if (!dataPackSettings.getDisabled().contains(s1) && !set.contains(s1)) {
+                    MinecraftServer.LOGGER.info("Found new data pack {}, loading it automatically", s1);
+                    set.add(s1);
+                }
+            }
+
+            if (set.isEmpty()) {
+                MinecraftServer.LOGGER.info("No datapacks selected, forcing vanilla");
+                set.add("vanilla");
+            }
+
+            resourcePackManager.setSelected((Collection) set);
+            return MinecraftServer.getSelectedPacks(resourcePackManager);
+        }
+    }
+
+    private static DataPackConfig getSelectedPacks(PackRepository dataPackManager) {
+        Collection<String> collection = dataPackManager.getSelectedIds();
+        List<String> list = ImmutableList.copyOf(collection);
+        List<String> list1 = (List) dataPackManager.getAvailableIds().stream().filter((s) -> {
+            return !collection.contains(s);
+        }).collect(ImmutableList.toImmutableList());
+
+        return new DataPackConfig(list, list1);
+    }
+
+    public void kickUnlistedPlayers(CommandSourceStack source) {
+        if (this.isEnforceWhitelist()) {
+            PlayerList playerlist = source.getServer().getPlayerList();
+            UserWhiteList whitelist = playerlist.getWhiteList();
+            if (!((DedicatedServer)getServer()).getProperties().whiteList.get()) return; // Paper - white list not enabled
+            List<ServerPlayer> list = Lists.newArrayList(playerlist.getPlayers());
+            Iterator iterator = list.iterator();
+
+            while (iterator.hasNext()) {
+                ServerPlayer entityplayer = (ServerPlayer) iterator.next();
+
+                if (!whitelist.isWhiteListed(entityplayer.getGameProfile()) && !this.getPlayerList().isOp(entityplayer.getGameProfile())) { // Paper - Fix kicking ops when whitelist is reloaded (MC-171420)
+                    entityplayer.connection.disconnect(org.spigotmc.SpigotConfig.whitelistMessage, org.bukkit.event.player.PlayerKickEvent.Cause.WHITELIST); // Paper - use configurable message
+                }
+            }
+
+        }
+    }
+
+    public PackRepository getPackRepository() {
+        return this.packRepository;
+    }
+
+    public Commands getCommands() {
+        return this.resources.getCommands();
+    }
+
+    public CommandSourceStack createCommandSourceStack() {
+        ServerLevel worldserver = this.overworld();
+
+        return new CommandSourceStack(this, worldserver == null ? Vec3.ZERO : Vec3.atLowerCornerOf((Vec3i) worldserver.getSharedSpawnPos()), Vec2.ZERO, worldserver, 4, "Server", new TextComponent("Server"), this, (Entity) null);
+    }
+
+    @Override
+    public boolean acceptsSuccess() {
+        return true;
+    }
+
+    @Override
+    public boolean acceptsFailure() {
+        return true;
+    }
+
+    @Override
+    public abstract boolean shouldInformAdmins();
+
+    public RecipeManager getRecipeManager() {
+        return this.resources.getRecipeManager();
+    }
+
+    public TagContainer getTags() {
+        return this.resources.getTags();
+    }
+
+    public ServerScoreboard getScoreboard() {
+        return this.scoreboard;
+    }
+
+    public CommandStorage getCommandStorage() {
+        if (this.commandStorage == null) {
+            throw new NullPointerException("Called before server init");
+        } else {
+            return this.commandStorage;
+        }
+    }
+
+    public LootTables getLootTables() {
+        return this.resources.getLootTables();
+    }
+
+    public PredicateManager getPredicateManager() {
+        return this.resources.getPredicateManager();
+    }
+
+    public ItemModifierManager getItemModifierManager() {
+        return this.resources.getItemModifierManager();
+    }
+
+    public GameRules getGameRules() {
+        return this.overworld().getGameRules();
+    }
+
+    public CustomBossEvents getCustomBossEvents() {
+        return this.customBossEvents;
+    }
+
+    public boolean isEnforceWhitelist() {
+        return this.enforceWhitelist;
+    }
+
+    public void setEnforceWhitelist(boolean whitelistEnabled) {
+        this.enforceWhitelist = whitelistEnabled;
+    }
+
+    public float getAverageTickTime() {
+        return this.averageTickTime;
+    }
+
+    public int getProfilePermissions(GameProfile profile) {
+        if (this.getPlayerList().isOp(profile)) {
+            ServerOpListEntry oplistentry = (ServerOpListEntry) this.getPlayerList().getOps().get(profile);
+
+            return oplistentry != null ? oplistentry.getLevel() : (this.isSingleplayerOwner(profile) ? 4 : (this.isSingleplayer() ? (this.getPlayerList().isAllowCheatsForAllPlayers() ? 4 : 0) : this.getOperatorUserPermissionLevel()));
+        } else {
+            return 0;
+        }
+    }
+
+    public FrameTimer getFrameTimer() {
+        return this.frameTimer;
+    }
+
+    public ProfilerFiller getProfiler() {
+        if (gg.airplane.AirplaneConfig.disableMethodProfiler) return net.minecraft.util.profiling.InactiveProfiler.INSTANCE;
+        return this.profiler;
+    }
+
+    public abstract boolean isSingleplayerOwner(GameProfile profile);
+
+    public void dumpServerProperties(Path file) throws IOException {}
+
+    private void saveDebugReport(Path path) {
+        Path path1 = path.resolve("levels");
+
+        try {
+            Iterator iterator = this.levels.entrySet().iterator();
+
+            while (iterator.hasNext()) {
+                Entry<ResourceKey<Level>, ServerLevel> entry = (Entry) iterator.next();
+                ResourceLocation minecraftkey = ((ResourceKey) entry.getKey()).location();
+                Path path2 = path1.resolve(minecraftkey.getNamespace()).resolve(minecraftkey.getPath());
+
+                Files.createDirectories(path2);
+                ((ServerLevel) entry.getValue()).saveDebugReport(path2);
+            }
+
+            this.dumpGameRules(path.resolve("gamerules.txt"));
+            this.dumpClasspath(path.resolve("classpath.txt"));
+            this.dumpMiscStats(path.resolve("stats.txt"));
+            this.dumpThreads(path.resolve("threads.txt"));
+            this.dumpServerProperties(path.resolve("server.properties.txt"));
+        } catch (IOException ioexception) {
+            MinecraftServer.LOGGER.warn("Failed to save debug report", ioexception);
+        }
+
+    }
+
+    private void dumpMiscStats(Path path) throws IOException {
+        BufferedWriter bufferedwriter = Files.newBufferedWriter(path);
+
+        try {
+            bufferedwriter.write(String.format("pending_tasks: %d\n", this.getPendingTasksCount()));
+            bufferedwriter.write(String.format("average_tick_time: %f\n", this.getAverageTickTime()));
+            bufferedwriter.write(String.format("tick_times: %s\n", Arrays.toString(this.tickTimes)));
+            bufferedwriter.write(String.format("queue: %s\n", Util.backgroundExecutor()));
+        } catch (Throwable throwable) {
+            if (bufferedwriter != null) {
+                try {
+                    bufferedwriter.close();
+                } catch (Throwable throwable1) {
+                    throwable.addSuppressed(throwable1);
+                }
+            }
+
+            throw throwable;
+        }
+
+        if (bufferedwriter != null) {
+            bufferedwriter.close();
+        }
+
+    }
+
+    private void dumpGameRules(Path path) throws IOException {
+        BufferedWriter bufferedwriter = Files.newBufferedWriter(path);
+
+        try {
+            final List<String> list = Lists.newArrayList();
+            final GameRules gamerules = this.getGameRules();
+
+            GameRules.visitGameRuleTypes(new GameRules.GameRuleTypeVisitor() {
+                @Override
+                public <T extends GameRules.Value<T>> void visit(GameRules.Key<T> key, GameRules.Type<T> type) {
+                    list.add(String.format("%s=%s\n", key.getId(), gamerules.getRule(key)));
+                }
+            });
+            Iterator iterator = list.iterator();
+
+            while (iterator.hasNext()) {
+                String s = (String) iterator.next();
+
+                bufferedwriter.write(s);
+            }
+        } catch (Throwable throwable) {
+            if (bufferedwriter != null) {
+                try {
+                    bufferedwriter.close();
+                } catch (Throwable throwable1) {
+                    throwable.addSuppressed(throwable1);
+                }
+            }
+
+            throw throwable;
+        }
+
+        if (bufferedwriter != null) {
+            bufferedwriter.close();
+        }
+
+    }
+
+    private void dumpClasspath(Path path) throws IOException {
+        BufferedWriter bufferedwriter = Files.newBufferedWriter(path);
+
+        try {
+            String s = System.getProperty("java.class.path");
+            String s1 = System.getProperty("path.separator");
+            Iterator iterator = Splitter.on(s1).split(s).iterator();
+
+            while (iterator.hasNext()) {
+                String s2 = (String) iterator.next();
+
+                bufferedwriter.write(s2);
+                bufferedwriter.write("\n");
+            }
+        } catch (Throwable throwable) {
+            if (bufferedwriter != null) {
+                try {
+                    bufferedwriter.close();
+                } catch (Throwable throwable1) {
+                    throwable.addSuppressed(throwable1);
+                }
+            }
+
+            throw throwable;
+        }
+
+        if (bufferedwriter != null) {
+            bufferedwriter.close();
+        }
+
+    }
+
+    private void dumpThreads(Path path) throws IOException {
+        ThreadMXBean threadmxbean = ManagementFactory.getThreadMXBean();
+        ThreadInfo[] athreadinfo = threadmxbean.dumpAllThreads(true, true);
+
+        Arrays.sort(athreadinfo, Comparator.comparing(ThreadInfo::getThreadName));
+        BufferedWriter bufferedwriter = Files.newBufferedWriter(path);
+
+        try {
+            ThreadInfo[] athreadinfo1 = athreadinfo;
+            int i = athreadinfo.length;
+
+            for (int j = 0; j < i; ++j) {
+                ThreadInfo threadinfo = athreadinfo1[j];
+
+                bufferedwriter.write(threadinfo.toString());
+                bufferedwriter.write(10);
+            }
+        } catch (Throwable throwable) {
+            if (bufferedwriter != null) {
+                try {
+                    bufferedwriter.close();
+                } catch (Throwable throwable1) {
+                    throwable.addSuppressed(throwable1);
+                }
+            }
+
+            throw throwable;
+        }
+
+        if (bufferedwriter != null) {
+            bufferedwriter.close();
+        }
+
+    }
+
+    // CraftBukkit start
+    @Override
+    public boolean isSameThread() {
+        return super.isSameThread() /*|| this.isStopped()*/; // CraftBukkit - MC-142590 // Paper - causes issues elsewhere
+    }
+
+    public boolean isDebugging() {
+        return false;
+    }
+
+    @Deprecated
+    public static MinecraftServer getServer() {
+        return SERVER; // Paper
+    }
+    // CraftBukkit end
+
+    private void startMetricsRecordingTick() {
+        if (this.willStartRecordingMetrics) {
+            this.metricsRecorder = ActiveMetricsRecorder.createStarted(new ServerMetricsSamplersProvider(Util.timeSource, this.isDedicatedServer()), Util.timeSource, Util.ioPool(), new MetricsPersister("server"), this.onMetricsRecordingStopped, (path) -> {
+                this.executeBlocking(() -> {
+                    this.saveDebugReport(path.resolve("server"));
+                });
+                this.onMetricsRecordingFinished.accept(path);
+            });
+            this.willStartRecordingMetrics = false;
+        }
+
+        this.profiler = SingleTickProfiler.decorateFiller(this.metricsRecorder.getProfiler(), SingleTickProfiler.createTickProfiler("Server"));
+        this.metricsRecorder.startTick();
+        this.profiler.startTick();
+    }
+
+    private void endMetricsRecordingTick() {
+        this.profiler.endTick();
+        this.metricsRecorder.endTick();
+    }
+
+    public boolean isRecordingMetrics() {
+        return this.metricsRecorder.isRecording();
+    }
+
+    public void startRecordingMetrics(Consumer<ProfileResults> resultConsumer, Consumer<Path> dumpConsumer) {
+        this.onMetricsRecordingStopped = (methodprofilerresults) -> {
+            this.stopRecordingMetrics();
+            resultConsumer.accept(methodprofilerresults);
+        };
+        this.onMetricsRecordingFinished = dumpConsumer;
+        this.willStartRecordingMetrics = true;
+    }
+
+    public void stopRecordingMetrics() {
+        this.metricsRecorder = InactiveMetricsRecorder.INSTANCE;
+    }
+
+    public void finishRecordingMetrics() {
+        this.metricsRecorder.end();
+    }
+
+    public Path getWorldPath(LevelResource worldSavePath) {
+        return this.storageSource.getLevelPath(worldSavePath);
+    }
+
+    public boolean forceSynchronousWrites() {
+        return true;
+    }
+
+    public StructureManager getStructureManager() {
+        return this.structureManager;
+    }
+
+    public WorldData getWorldData() {
+        return this.worldData;
+    }
+
+    public RegistryAccess registryAccess() {
+        return this.registryHolder;
+    }
+
+    public TextFilter createTextFilterForPlayer(ServerPlayer player) {
+        return TextFilter.DUMMY;
+    }
+
+    public boolean isResourcePackRequired() {
+        return false;
+    }
+
+    public ServerPlayerGameMode createGameModeForPlayer(ServerPlayer player) {
+        return (ServerPlayerGameMode) (this.isDemo() ? new DemoMode(player) : new ServerPlayerGameMode(player));
+    }
+
+    @Nullable
+    public GameType getForcedGameType() {
+        return null;
+    }
+
+    public ResourceManager getResourceManager() {
+        return this.resources.getResourceManager();
+    }
+
+    @Nullable
+    public Component getResourcePackPrompt() {
+        return null;
+    }
+
+    public boolean isTimeProfilerRunning() {
+        return this.debugCommandProfilerDelayStart || this.debugCommandProfiler != null;
+    }
+
+    public void startTimeProfiler() {
+        this.debugCommandProfilerDelayStart = true;
+    }
+
+    public ProfileResults stopTimeProfiler() {
+        if (this.debugCommandProfiler == null) {
+            return EmptyProfileResults.EMPTY;
+        } else {
+            ProfileResults methodprofilerresults = this.debugCommandProfiler.stop(Util.getNanos(), this.tickCount);
+
+            this.debugCommandProfiler = null;
+            return methodprofilerresults;
+        }
+    }
+
+    private static class TimeProfiler {
+
+        final long startNanos;
+        final int startTick;
+
+        TimeProfiler(long time, int tick) {
+            this.startNanos = time;
+            this.startTick = tick;
+        }
+
+        ProfileResults stop(final long endTime, final int endTick) {
+            return new ProfileResults() {
+                @Override
+                public List<ResultField> getTimes(String parentPath) {
+                    return Collections.emptyList();
+                }
+
+                @Override
+                public boolean saveResults(Path path) {
+                    return false;
+                }
+
+                @Override
+                public long getStartTimeNano() {
+                    return TimeProfiler.this.startNanos;
+                }
+
+                @Override
+                public int getStartTimeTicks() {
+                    return TimeProfiler.this.startTick;
+                }
+
+                @Override
+                public long getEndTimeNano() {
+                    return endTime;
+                }
+
+                @Override
+                public int getEndTimeTicks() {
+                    return endTick;
+                }
+
+                @Override
+                public String getProfilerResults() {
+                    return "";
+                }
+            };
+        }
+    }
+    // Paper start
+    public static class TickTimes {
+        private final long[] times;
+
+        public TickTimes(int length) {
+            times = new long[length];
+        }
+
+        void add(int index, long time) {
+            times[index % times.length] = time;
+        }
+
+        public long[] getTimes() {
+            return times.clone();
+        }
+
+        public double getAverage() {
+            long total = 0L;
+            for (long value : times) {
+                total += value;
+            }
+            return ((double) total / (double) times.length) * 1.0E-6D;
+        }
+    }
+    // Paper end
+}
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java.orig b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java.orig
new file mode 100644
index 0000000000000000000000000000000000000000..dfa20c3d035dd03d909d911dda75418e3f52f181
--- /dev/null
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java.orig
@@ -0,0 +1,905 @@
+package net.minecraft.server.dedicated;
+
+import com.google.common.base.Strings;
+import com.google.common.collect.Lists;
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.GameProfileRepository;
+import com.mojang.authlib.minecraft.MinecraftSessionService;
+import com.mojang.datafixers.DataFixer;
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.net.InetAddress;
+import java.net.Proxy;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Collections;
+import java.util.List;
+import java.util.Locale;
+import java.util.Optional;
+import java.util.concurrent.Executor;
+import java.util.function.BooleanSupplier;
+import java.util.regex.Pattern;
+import javax.annotation.Nullable;
+import net.minecraft.DefaultUncaughtExceptionHandler;
+import net.minecraft.DefaultUncaughtExceptionHandlerWithName;
+import net.minecraft.SharedConstants;
+import net.minecraft.SystemReport;
+import net.minecraft.Util;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.NonNullList;
+import net.minecraft.core.RegistryAccess;
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.ConsoleInput;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.ServerInterface;
+import net.minecraft.server.ServerResources;
+import net.minecraft.server.gui.MinecraftServerGui;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.level.progress.ChunkProgressListenerFactory;
+import net.minecraft.server.network.TextFilter;
+import net.minecraft.server.network.TextFilterClient;
+import net.minecraft.server.packs.repository.PackRepository;
+import net.minecraft.server.players.GameProfileCache;
+import net.minecraft.server.players.OldUsersConverter;
+import net.minecraft.server.players.PlayerList;
+import net.minecraft.server.rcon.RconConsoleSource;
+import net.minecraft.server.rcon.thread.QueryThreadGs4;
+import net.minecraft.server.rcon.thread.RconThread;
+import net.minecraft.util.Mth;
+import net.minecraft.util.monitoring.jmx.MinecraftServerStatistics;
+import net.minecraft.world.Snooper;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.CreativeModeTab;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.DataPackConfig;
+import net.minecraft.world.level.GameRules;
+import net.minecraft.world.level.GameType;
+import net.minecraft.world.level.block.entity.SkullBlockEntity;
+import net.minecraft.world.level.storage.LevelStorageSource;
+import net.minecraft.world.level.storage.WorldData;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.apache.logging.log4j.Level;
+import org.apache.logging.log4j.io.IoBuilder;
+import org.bukkit.command.CommandSender;
+import co.aikar.timings.MinecraftTimings; // Paper
+import org.bukkit.event.server.ServerCommandEvent;
+import org.bukkit.craftbukkit.util.Waitable;
+import org.bukkit.event.server.RemoteServerCommandEvent;
+// CraftBukkit end
+
+public class DedicatedServer extends MinecraftServer implements ServerInterface {
+
+    static final Logger LOGGER = LogManager.getLogger();
+    private static final int CONVERSION_RETRY_DELAY_MS = 5000;
+    private static final int CONVERSION_RETRIES = 2;
+    private static final Pattern SHA1 = Pattern.compile("^[a-fA-F0-9]{40}$");
+    private final java.util.Queue<ConsoleInput> serverCommandQueue = new java.util.concurrent.ConcurrentLinkedQueue<>(); // Paper - use a proper queue
+    private QueryThreadGs4 queryThreadGs4;
+    public final RconConsoleSource rconConsoleSource;
+    private RconThread rconThread;
+    public DedicatedServerSettings settings;
+    @Nullable
+    private MinecraftServerGui gui;
+    @Nullable
+    private final TextFilterClient textFilterClient;
+    @Nullable
+    private final Component resourcePackPrompt;
+
+    // CraftBukkit start - Signature changed
+    public DedicatedServer(joptsimple.OptionSet options, DataPackConfig datapackconfiguration, Thread thread, RegistryAccess.RegistryHolder iregistrycustom_dimension, LevelStorageSource.LevelStorageAccess convertable_conversionsession, PackRepository resourcepackrepository, ServerResources datapackresources, WorldData savedata, DedicatedServerSettings dedicatedserversettings, DataFixer datafixer, MinecraftSessionService minecraftsessionservice, GameProfileRepository gameprofilerepository, GameProfileCache usercache, ChunkProgressListenerFactory worldloadlistenerfactory) {
+        super(options, datapackconfiguration, thread, iregistrycustom_dimension, convertable_conversionsession, savedata, resourcepackrepository, Proxy.NO_PROXY, datafixer, datapackresources, minecraftsessionservice, gameprofilerepository, usercache, worldloadlistenerfactory);
+        // CraftBukkit end
+        this.settings = dedicatedserversettings;
+        this.rconConsoleSource = new RconConsoleSource(this);
+        this.textFilterClient = TextFilterClient.createFromConfig(dedicatedserversettings.getProperties().textFilteringConfig);
+        this.resourcePackPrompt = DedicatedServer.parseResourcePackPrompt(dedicatedserversettings);
+    }
+
+    @Override
+    public boolean initServer() throws IOException {
+        Thread thread = new Thread("Server console handler") {
+            public void run() {
+                // CraftBukkit start
+                if (!org.bukkit.craftbukkit.Main.useConsole) {
+                    return;
+                }
+                // Paper start - Use TerminalConsoleAppender
+                new com.destroystokyo.paper.console.PaperConsole(DedicatedServer.this).start();
+                /*
+                jline.console.ConsoleReader bufferedreader = reader;
+
+                // MC-33041, SPIGOT-5538: if System.in is not valid due to javaw, then return
+                try {
+                    System.in.available();
+                } catch (IOException ex) {
+                    return;
+                }
+                // CraftBukkit end
+
+                String s;
+
+                try {
+                    // CraftBukkit start - JLine disabling compatibility
+                    while (!DedicatedServer.this.isStopped() && DedicatedServer.this.isRunning()) {
+                        if (org.bukkit.craftbukkit.Main.useJline) {
+                            s = bufferedreader.readLine(">", null);
+                        } else {
+                            s = bufferedreader.readLine();
+                        }
+
+                        // SPIGOT-5220: Throttle if EOF (ctrl^d) or stdin is /dev/null
+                        if (s == null) {
+                            try {
+                                Thread.sleep(50L);
+                            } catch (InterruptedException ex) {
+                                Thread.currentThread().interrupt();
+                            }
+                            continue;
+                        }
+                        if (s.trim().length() > 0) { // Trim to filter lines which are just spaces
+                            DedicatedServer.this.issueCommand(s, DedicatedServer.this.getServerCommandListener());
+                        }
+                        // CraftBukkit end
+                    }
+                } catch (IOException ioexception) {
+                    DedicatedServer.LOGGER.error("Exception handling console input", ioexception);
+                }
+
+                */
+                // Paper end
+            }
+        };
+
+        // CraftBukkit start - TODO: handle command-line logging arguments
+        java.util.logging.Logger global = java.util.logging.Logger.getLogger("");
+        global.setUseParentHandlers(false);
+        for (java.util.logging.Handler handler : global.getHandlers()) {
+            global.removeHandler(handler);
+        }
+        global.addHandler(new org.bukkit.craftbukkit.util.ForwardLogHandler());
+
+        // Paper start - Not needed with TerminalConsoleAppender
+        final org.apache.logging.log4j.Logger logger = LogManager.getRootLogger();
+        /*
+        final org.apache.logging.log4j.core.Logger logger = ((org.apache.logging.log4j.core.Logger) LogManager.getRootLogger());
+        for (org.apache.logging.log4j.core.Appender appender : logger.getAppenders().values()) {
+            if (appender instanceof org.apache.logging.log4j.core.appender.ConsoleAppender) {
+                logger.removeAppender(appender);
+            }
+        }
+
+        new org.bukkit.craftbukkit.util.TerminalConsoleWriterThread(System.out, this.reader).start();
+        */
+        // Paper end
+
+        System.setOut(IoBuilder.forLogger(logger).setLevel(Level.INFO).buildPrintStream());
+        System.setErr(IoBuilder.forLogger(logger).setLevel(Level.WARN).buildPrintStream());
+        // CraftBukkit end
+
+        thread.setDaemon(true);
+        thread.setUncaughtExceptionHandler(new DefaultUncaughtExceptionHandler(DedicatedServer.LOGGER));
+        // thread.start(); // Paper - moved down
+        DedicatedServer.LOGGER.info("Starting minecraft server version {}", SharedConstants.getCurrentVersion().getName());
+        if (Runtime.getRuntime().maxMemory() / 1024L / 1024L < 512L) {
+            DedicatedServer.LOGGER.warn("To start the server with more ram, launch it as \"java -Xmx1024M -Xms1024M -jar minecraft_server.jar\"");
+        }
+
+        // Paper start - detect running as root
+        if (io.papermc.paper.util.ServerEnvironment.userIsRootOrAdmin()) {
+            DedicatedServer.LOGGER.warn("****************************");
+            DedicatedServer.LOGGER.warn("YOU ARE RUNNING THIS SERVER AS AN ADMINISTRATIVE OR ROOT USER. THIS IS NOT ADVISED.");
+            DedicatedServer.LOGGER.warn("YOU ARE OPENING YOURSELF UP TO POTENTIAL RISKS WHEN DOING THIS.");
+            DedicatedServer.LOGGER.warn("FOR MORE INFORMATION, SEE https://madelinemiller.dev/blog/root-minecraft-server/");
+            DedicatedServer.LOGGER.warn("****************************");
+        }
+        // Paper end
+
+        DedicatedServer.LOGGER.info("Loading properties");
+        DedicatedServerProperties dedicatedserverproperties = this.settings.getProperties();
+
+        if (this.isSingleplayer()) {
+            this.setLocalIp("127.0.0.1");
+        } else {
+            this.setUsesAuthentication(dedicatedserverproperties.onlineMode);
+            this.setPreventProxyConnections(dedicatedserverproperties.preventProxyConnections);
+            this.setLocalIp(dedicatedserverproperties.serverIp);
+        }
+        // Spigot start
+        this.setPlayerList((PlayerList) (new DedicatedPlayerList(this, this.registryHolder, this.playerDataStorage)));
+        org.spigotmc.SpigotConfig.init((java.io.File) options.valueOf("spigot-settings"));
+        org.spigotmc.SpigotConfig.registerCommands();
+        // Spigot end
+        // Paper start - moved up to right after PlayerList creation but before file load/save
+        if (this.convertOldUsers()) {
+            this.getProfileCache().save(false); // Paper
+        }
+        this.getPlayerList().loadAndSaveFiles(); // Must be after convertNames
+        // Paper end
+        // Paper start
+        try {
+            com.destroystokyo.paper.PaperConfig.init((java.io.File) options.valueOf("paper-settings"));
+        } catch (Exception e) {
+            DedicatedServer.LOGGER.error("Unable to load server configuration", e);
+            return false;
+        }
+        thread.start(); // Paper - start console thread after MinecraftServer.console & PaperConfig are initialized
+        com.destroystokyo.paper.PaperConfig.registerCommands();
+        // Fiadelity start
+        try {
+            me.kurumifake.FiadelityConfig.init((java.io.File) options.valueOf("fiadelity-settings"));
+        } catch (Exception e) {
+            DedicatedServer.LOGGER.error("Unable to load server configuration", e);
+            return false;
+        }
+        // Fiadelity end
+        // Purpur start
+        try {
+            net.pl3x.purpur.PurpurConfig.init((java.io.File) options.valueOf("purpur-settings"));
+        } catch (Exception e) {
+            DedicatedServer.LOGGER.error("Unable to load server configuration", e);
+            return false;
+        }
+        net.pl3x.purpur.PurpurConfig.registerCommands();
+        // Purpur end
+        com.destroystokyo.paper.VersionHistoryManager.INSTANCE.getClass(); // load version history now
+        io.papermc.paper.util.ObfHelper.INSTANCE.getClass(); // load mappings for stacktrace deobf and etc.
+        io.papermc.paper.brigadier.PaperBrigadierProviderImpl.INSTANCE.getClass(); // init PaperBrigadierProvider
+        // Paper end
+        gg.airplane.AirplaneConfig.load(); // Airplane - config
+        gg.airplane.commands.AirplaneCommands.init(); // Airplane - command
+
+        // Yatopia start
+        try {
+            me.titaniumtown.JettPackConfig.init((java.io.File) options.valueOf("jettpack-settings"));
+        } catch (Exception e) {
+            DedicatedServer.LOGGER.error("Unable to load server configuration", e);
+            return false;
+        }
+        // Yatopia end
+
+        this.setPvpAllowed(dedicatedserverproperties.pvp);
+        this.setFlightAllowed(dedicatedserverproperties.allowFlight);
+        this.setResourcePack(dedicatedserverproperties.resourcePack, this.getPackHash());
+        this.setMotd(dedicatedserverproperties.motd);
+        super.setPlayerIdleTimeout((Integer) dedicatedserverproperties.playerIdleTimeout.get());
+        this.setEnforceWhitelist(dedicatedserverproperties.enforceWhitelist);
+        // this.worldData.setGameType(dedicatedserverproperties.gamemode); // CraftBukkit - moved to world loading
+        DedicatedServer.LOGGER.info("Default game type: {}", dedicatedserverproperties.gamemode);
+        // Paper start - Unix domain socket support
+        java.net.SocketAddress bindAddress;
+        if (this.getLocalIp().startsWith("unix:")) {
+            if (!io.netty.channel.epoll.Epoll.isAvailable()) {
+                DedicatedServer.LOGGER.fatal("**** INVALID CONFIGURATION!");
+                DedicatedServer.LOGGER.fatal("You are trying to use a Unix domain socket but you're not on a supported OS.");
+                return false;
+            } else if (!com.destroystokyo.paper.PaperConfig.velocitySupport && !org.spigotmc.SpigotConfig.bungee) {
+                DedicatedServer.LOGGER.fatal("**** INVALID CONFIGURATION!");
+                DedicatedServer.LOGGER.fatal("Unix domain sockets require IPs to be forwarded from a proxy.");
+                return false;
+            }
+            bindAddress = new io.netty.channel.unix.DomainSocketAddress(this.getLocalIp().substring("unix:".length()));
+        } else {
+        InetAddress inetaddress = null;
+
+        if (!this.getLocalIp().isEmpty()) {
+            inetaddress = InetAddress.getByName(this.getLocalIp());
+        }
+
+        if (this.getPort() < 0) {
+            this.setPort(dedicatedserverproperties.serverPort);
+        }
+        bindAddress = new java.net.InetSocketAddress(inetaddress, this.getPort());
+        }
+        // Paper end
+
+        this.initializeKeyPair();
+        DedicatedServer.LOGGER.info("Starting Minecraft server on {}:{}", this.getLocalIp().isEmpty() ? "*" : this.getLocalIp(), this.getPort());
+
+        try {
+            this.getConnection().bind(bindAddress); // Paper - Unix domain socket support
+        } catch (IOException ioexception) {
+            DedicatedServer.LOGGER.warn("**** FAILED TO BIND TO PORT!");
+            DedicatedServer.LOGGER.warn("The exception was: {}", ioexception.toString());
+            DedicatedServer.LOGGER.warn("Perhaps a server is already running on that port?");
+            return false;
+        }
+
+        // CraftBukkit start
+        // this.a((PlayerList) (new DedicatedPlayerList(this, this.customRegistry, this.worldNBTStorage))); // Spigot - moved up
+        server.loadPlugins();
+        server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.STARTUP);
+        // CraftBukkit end
+
+        if (!this.usesAuthentication()) {
+            DedicatedServer.LOGGER.warn("**** SERVER IS RUNNING IN OFFLINE/INSECURE MODE!");
+            DedicatedServer.LOGGER.warn("The server will make no attempt to authenticate usernames. Beware.");
+            // Spigot start
+            if (org.spigotmc.SpigotConfig.bungee) {
+                DedicatedServer.LOGGER.warn("Whilst this makes it possible to use BungeeCord, unless access to your server is properly restricted, it also opens up the ability for hackers to connect with any username they choose.");
+                DedicatedServer.LOGGER.warn("Please see http://www.spigotmc.org/wiki/firewall-guide/ for further information.");
+            } else {
+                DedicatedServer.LOGGER.warn("While this makes the game possible to play without internet access, it also opens up the ability for hackers to connect with any username they choose.");
+            }
+            // Spigot end
+            DedicatedServer.LOGGER.warn("To change this, set \"online-mode\" to \"true\" in the server.properties file.");
+        }
+
+
+        if (!OldUsersConverter.serverReadyAfterUserconversion(this)) {
+            return false;
+        } else {
+            // this.a((PlayerList) (new DedicatedPlayerList(this, this.customRegistry, this.worldNBTStorage))); // CraftBukkit - moved up
+            long i = Util.getNanos();
+
+            SkullBlockEntity.setProfileCache(this.getProfileCache());
+            SkullBlockEntity.setSessionService(this.getSessionService());
+            SkullBlockEntity.setMainThreadExecutor((Executor) this);
+            GameProfileCache.setUsesAuthentication(this.usesAuthentication());
+            DedicatedServer.LOGGER.info("Preparing level \"{}\"", this.getLevelIdName());
+            this.loadWorld(storageSource.getLevelId()); // CraftBukkit
+            long j = Util.getNanos() - i;
+            String s = String.format(Locale.ROOT, "%.3fs", (double) j / 1.0E9D);
+
+            //DedicatedServer.LOGGER.info("Done ({})! For help, type \"help\"", s); // Paper moved to after init
+            if (dedicatedserverproperties.announcePlayerAchievements != null) {
+                ((GameRules.BooleanValue) this.getGameRules().getRule(GameRules.RULE_ANNOUNCE_ADVANCEMENTS)).set(dedicatedserverproperties.announcePlayerAchievements, (MinecraftServer) this);
+            }
+
+            if (dedicatedserverproperties.enableQuery) {
+                DedicatedServer.LOGGER.info("Starting GS4 status listener");
+                this.queryThreadGs4 = QueryThreadGs4.create((ServerInterface) this);
+            }
+
+            if (dedicatedserverproperties.enableRcon) {
+                DedicatedServer.LOGGER.info("Starting remote control listener");
+                this.rconThread = RconThread.create((ServerInterface) this);
+                this.remoteConsole = new org.bukkit.craftbukkit.command.CraftRemoteConsoleCommandSender(this.rconConsoleSource); // CraftBukkit
+            }
+
+            if (false && this.getMaxTickLength() > 0L) {  // Spigot - disable
+                Thread thread1 = new Thread(new ServerWatchdog(this));
+
+                thread1.setUncaughtExceptionHandler(new DefaultUncaughtExceptionHandlerWithName(DedicatedServer.LOGGER));
+                thread1.setName("Server Watchdog");
+                thread1.setDaemon(true);
+                thread1.start();
+            }
+
+            Items.AIR.fillItemCategory(CreativeModeTab.TAB_SEARCH, NonNullList.create());
+            if (dedicatedserverproperties.enableJmxMonitoring) {
+                MinecraftServerStatistics.registerJmxMonitoring((MinecraftServer) this);
+                DedicatedServer.LOGGER.info("JMX monitoring enabled");
+            }
+
+            if (me.titaniumtown.JettPackConfig.enableAsyncMobSpawning) mobSpawnExecutor.start(); // Pufferfish
+            return true;
+        }
+    }
+
+    @Override
+    public boolean isSpawningAnimals() {
+        return this.getProperties().spawnAnimals && super.isSpawningAnimals();
+    }
+
+    @Override
+    public boolean isSpawningMonsters() {
+        return this.settings.getProperties().spawnMonsters && super.isSpawningMonsters();
+    }
+
+    @Override
+    public boolean areNpcsEnabled() {
+        return this.settings.getProperties().spawnNpcs && super.areNpcsEnabled();
+    }
+
+    public String getPackHash() {
+        DedicatedServerProperties dedicatedserverproperties = this.settings.getProperties();
+        String s;
+
+        if (!dedicatedserverproperties.resourcePackSha1.isEmpty()) {
+            s = dedicatedserverproperties.resourcePackSha1;
+            if (!Strings.isNullOrEmpty(dedicatedserverproperties.resourcePackHash)) {
+                DedicatedServer.LOGGER.warn("resource-pack-hash is deprecated and found along side resource-pack-sha1. resource-pack-hash will be ignored.");
+            }
+        } else if (!Strings.isNullOrEmpty(dedicatedserverproperties.resourcePackHash)) {
+            DedicatedServer.LOGGER.warn("resource-pack-hash is deprecated. Please use resource-pack-sha1 instead.");
+            s = dedicatedserverproperties.resourcePackHash;
+        } else {
+            s = "";
+        }
+
+        if (!s.isEmpty() && !DedicatedServer.SHA1.matcher(s).matches()) {
+            DedicatedServer.LOGGER.warn("Invalid sha1 for ressource-pack-sha1");
+        }
+
+        if (!dedicatedserverproperties.resourcePack.isEmpty() && s.isEmpty()) {
+            DedicatedServer.LOGGER.warn("You specified a resource pack without providing a sha1 hash. Pack will be updated on the client only if you change the name of the pack.");
+        }
+
+        return s;
+    }
+
+    @Override
+    public DedicatedServerProperties getProperties() {
+        return this.settings.getProperties();
+    }
+
+    @Override
+    public void forceDifficulty() {
+        //this.a(this.getDedicatedServerProperties().difficulty, true); // Paper - Don't overwrite level.dat's difficulty, keep current
+    }
+
+    @Override
+    public boolean isHardcore() {
+        return this.getProperties().hardcore;
+    }
+
+    @Override
+    public SystemReport fillServerSystemReport(SystemReport details) {
+        details.setDetail("Is Modded", () -> {
+            return (String) this.getModdedStatus().orElse("Unknown (can't tell)");
+        });
+        details.setDetail("Type", () -> {
+            return "Dedicated Server (map_server.txt)";
+        });
+        return details;
+    }
+
+    @Override
+    public void dumpServerProperties(Path file) throws IOException {
+        DedicatedServerProperties dedicatedserverproperties = this.getProperties();
+        BufferedWriter bufferedwriter = Files.newBufferedWriter(file);
+
+        try {
+            bufferedwriter.write(String.format("sync-chunk-writes=%s%n", dedicatedserverproperties.syncChunkWrites));
+            bufferedwriter.write(String.format("gamemode=%s%n", dedicatedserverproperties.gamemode));
+            bufferedwriter.write(String.format("spawn-monsters=%s%n", dedicatedserverproperties.spawnMonsters));
+            bufferedwriter.write(String.format("entity-broadcast-range-percentage=%d%n", dedicatedserverproperties.entityBroadcastRangePercentage));
+            bufferedwriter.write(String.format("max-world-size=%d%n", dedicatedserverproperties.maxWorldSize));
+            bufferedwriter.write(String.format("spawn-npcs=%s%n", dedicatedserverproperties.spawnNpcs));
+            bufferedwriter.write(String.format("view-distance=%d%n", dedicatedserverproperties.viewDistance));
+            bufferedwriter.write(String.format("spawn-animals=%s%n", dedicatedserverproperties.spawnAnimals));
+            bufferedwriter.write(String.format("generate-structures=%s%n", dedicatedserverproperties.getWorldGenSettings((RegistryAccess) this.registryHolder).generateFeatures()));
+            bufferedwriter.write(String.format("use-native=%s%n", dedicatedserverproperties.useNativeTransport));
+            bufferedwriter.write(String.format("rate-limit=%d%n", dedicatedserverproperties.rateLimitPacketsPerSecond));
+        } catch (Throwable throwable) {
+            if (bufferedwriter != null) {
+                try {
+                    bufferedwriter.close();
+                } catch (Throwable throwable1) {
+                    throwable.addSuppressed(throwable1);
+                }
+            }
+
+            throw throwable;
+        }
+
+        if (bufferedwriter != null) {
+            bufferedwriter.close();
+        }
+
+    }
+
+    @Override
+    public Optional<String> getModdedStatus() {
+        String s = this.getServerModName();
+
+        return !"vanilla".equals(s) ? Optional.of("Definitely; Server brand changed to '" + s + "'") : Optional.empty();
+    }
+
+    @Override
+    public void onServerExit() {
+        if (this.textFilterClient != null) {
+            this.textFilterClient.close();
+        }
+
+        if (this.gui != null) {
+            this.gui.close();
+        }
+
+        if (this.rconThread != null) {
+            //this.remoteControlListener.b(); // Paper - don't wait for remote connections
+        }
+
+        if (this.queryThreadGs4 != null) {
+            //this.remoteStatusListener.b(); // Paper - don't wait for remote connections
+        }
+
+        hasFullyShutdown = true; // Paper
+        System.exit(this.abnormalExit ? 70 : 0); // CraftBukkit // Paper
+    }
+
+    @Override
+    public void tickChildren(BooleanSupplier shouldKeepTicking) {
+        super.tickChildren(shouldKeepTicking);
+        this.handleConsoleInputs();
+    }
+
+    @Override
+    public boolean isNetherEnabled() {
+        return this.getProperties().allowNether;
+    }    
+
+    public void handleConsoleInput(String command, CommandSourceStack commandSource) {
+        this.serverCommandQueue.add(new ConsoleInput(command, commandSource));
+    }
+
+    public void handleConsoleInputs() {
+        MinecraftTimings.serverCommandTimer.startTiming(); // Spigot
+        // Paper start - use proper queue
+        ConsoleInput servercommand;
+        while ((servercommand = this.serverCommandQueue.poll()) != null) {
+            // Paper end
+
+            // CraftBukkit start - ServerCommand for preprocessing
+            ServerCommandEvent event = new ServerCommandEvent(console, servercommand.msg);
+            server.getPluginManager().callEvent(event);
+            if (event.isCancelled()) continue;
+            servercommand = new ConsoleInput(event.getCommand(), servercommand.source);
+
+            // this.getCommandDispatcher().a(servercommand.source, servercommand.command); // Called in dispatchServerCommand
+            server.dispatchServerCommand(console, servercommand);
+            // CraftBukkit end
+        }
+
+        MinecraftTimings.serverCommandTimer.stopTiming(); // Spigot
+    }
+
+    @Override
+    public boolean isDedicatedServer() {
+        return true;
+    }
+
+    @Override
+    public int getRateLimitPacketsPerSecond() {
+        return this.getProperties().rateLimitPacketsPerSecond;
+    }
+
+    @Override
+    public boolean isEpollEnabled() {
+        return this.getProperties().useNativeTransport;
+    }
+
+    @Override
+    public DedicatedPlayerList getPlayerList() {
+        return (DedicatedPlayerList) super.getPlayerList();
+    }
+
+    @Override
+    public boolean isPublished() {
+        return true;
+    }
+
+    @Override
+    public String getServerIp() {
+        return this.getLocalIp();
+    }
+
+    @Override
+    public int getServerPort() {
+        return this.getPort();
+    }
+
+    @Override
+    public String getServerName() {
+        return this.getMotd();
+    }
+
+    public void showGui() {
+        if (this.gui == null) {
+            this.gui = MinecraftServerGui.showFrameFor(this);
+        }
+
+    }
+
+    @Override
+    public boolean hasGui() {
+        return this.gui != null;
+    }
+
+    @Override
+    public boolean isCommandBlockEnabled() {
+        return this.getProperties().enableCommandBlock;
+    }
+
+    @Override
+    public int getSpawnProtectionRadius() {
+        return this.getProperties().spawnProtection;
+    }
+
+    @Override
+    public boolean isUnderSpawnProtection(ServerLevel world, BlockPos pos, Player player) {
+        if (world.dimension() != net.minecraft.world.level.Level.OVERWORLD) {
+            return false;
+        } else if (this.getPlayerList().getOps().isEmpty()) {
+            return false;
+        } else if (this.getPlayerList().isOp(player.getGameProfile())) {
+            return false;
+        } else if (this.getSpawnProtectionRadius() <= 0) {
+            return false;
+        } else {
+            BlockPos blockposition1 = world.getSharedSpawnPos();
+            int i = Mth.abs(pos.getX() - blockposition1.getX());
+            int j = Mth.abs(pos.getZ() - blockposition1.getZ());
+            int k = Math.max(i, j);
+
+            return k <= this.getSpawnProtectionRadius();
+        }
+    }
+
+    @Override
+    public boolean repliesToStatus() {
+        return this.getProperties().enableStatus;
+    }
+
+    @Override
+    public int getOperatorUserPermissionLevel() {
+        return this.getProperties().opPermissionLevel;
+    }
+
+    @Override
+    public int getFunctionCompilationLevel() {
+        return this.getProperties().functionPermissionLevel;
+    }
+
+    @Override
+    public void setPlayerIdleTimeout(int playerIdleTimeout) {
+        super.setPlayerIdleTimeout(playerIdleTimeout);
+        this.settings.update((dedicatedserverproperties) -> {
+            return (DedicatedServerProperties) dedicatedserverproperties.playerIdleTimeout.update(this.registryAccess(), playerIdleTimeout);
+        });
+    }
+
+    @Override
+    public boolean shouldRconBroadcast() {
+        return this.getProperties().broadcastRconToOps;
+    }
+
+    @Override
+    public boolean shouldInformAdmins() {
+        return this.getProperties().broadcastConsoleToOps;
+    }
+
+    @Override
+    public int getAbsoluteMaxWorldSize() {
+        return this.getProperties().maxWorldSize;
+    }
+
+    @Override
+    public int getCompressionThreshold() {
+        return this.getProperties().networkCompressionThreshold;
+    }
+
+    protected boolean convertOldUsers() {
+        boolean flag = false;
+
+        int i;
+
+        for (i = 0; !flag && i <= 2; ++i) {
+            if (i > 0) {
+                DedicatedServer.LOGGER.warn("Encountered a problem while converting the user banlist, retrying in a few seconds");
+                this.waitForRetry();
+            }
+
+            flag = OldUsersConverter.convertUserBanlist((MinecraftServer) this);
+        }
+
+        boolean flag1 = false;
+
+        for (i = 0; !flag1 && i <= 2; ++i) {
+            if (i > 0) {
+                DedicatedServer.LOGGER.warn("Encountered a problem while converting the ip banlist, retrying in a few seconds");
+                this.waitForRetry();
+            }
+
+            flag1 = OldUsersConverter.convertIpBanlist((MinecraftServer) this);
+        }
+
+        boolean flag2 = false;
+
+        for (i = 0; !flag2 && i <= 2; ++i) {
+            if (i > 0) {
+                DedicatedServer.LOGGER.warn("Encountered a problem while converting the op list, retrying in a few seconds");
+                this.waitForRetry();
+            }
+
+            flag2 = OldUsersConverter.convertOpsList(this);
+        }
+
+        boolean flag3 = false;
+
+        for (i = 0; !flag3 && i <= 2; ++i) {
+            if (i > 0) {
+                DedicatedServer.LOGGER.warn("Encountered a problem while converting the whitelist, retrying in a few seconds");
+                this.waitForRetry();
+            }
+
+            flag3 = OldUsersConverter.convertWhiteList(this);
+        }
+
+        boolean flag4 = false;
+
+        for (i = 0; !flag4 && i <= 2; ++i) {
+            if (i > 0) {
+                DedicatedServer.LOGGER.warn("Encountered a problem while converting the player save files, retrying in a few seconds");
+                this.waitForRetry();
+            }
+
+            flag4 = OldUsersConverter.convertPlayers(this);
+        }
+
+        return flag || flag1 || flag2 || flag3 || flag4;
+    }
+
+    private void waitForRetry() {
+        try {
+            Thread.sleep(5000L);
+        } catch (InterruptedException interruptedexception) {
+            ;
+        }
+    }
+
+    public long getMaxTickLength() {
+        return this.getProperties().maxTickTime;
+    }
+
+    @Override
+    public String getPluginNames() {
+        // CraftBukkit start - Whole method
+        StringBuilder result = new StringBuilder();
+        org.bukkit.plugin.Plugin[] plugins = server.getPluginManager().getPlugins();
+
+        result.append(server.getName());
+        result.append(" on Bukkit ");
+        result.append(server.getBukkitVersion());
+
+        if (plugins.length > 0 && server.getQueryPlugins()) {
+            result.append(": ");
+
+            for (int i = 0; i < plugins.length; i++) {
+                if (i > 0) {
+                    result.append("; ");
+                }
+
+                result.append(plugins[i].getDescription().getName());
+                result.append(" ");
+                result.append(plugins[i].getDescription().getVersion().replaceAll(";", ","));
+            }
+        }
+
+        return result.toString();
+        // CraftBukkit end
+    }
+
+    @Override
+    public String runCommand(String command) {
+        Waitable[] waitableArray = new Waitable[1];
+        this.rconConsoleSource.prepareForCommand();
+        this.executeBlocking(() -> {
+            // CraftBukkit start - fire RemoteServerCommandEvent
+            RemoteServerCommandEvent event = new RemoteServerCommandEvent(remoteConsole, command);
+            server.getPluginManager().callEvent(event);
+            if (event.isCancelled()) {
+                return;
+            }
+            // Paper start
+            if (command.toLowerCase().startsWith("timings") && command.toLowerCase().matches("timings (report|paste|get|merged|seperate)")) {
+                org.bukkit.command.BufferedCommandSender sender = new org.bukkit.command.BufferedCommandSender();
+                Waitable<String> waitable = new Waitable<String>() {
+                    @Override
+                    protected String evaluate() {
+                        return sender.getBuffer();
+                    }
+                };
+                waitableArray[0] = waitable;
+                co.aikar.timings.Timings.generateReport(new co.aikar.timings.TimingsReportListener(sender, waitable));
+            } else {
+            // Paper end
+            ConsoleInput serverCommand = new ConsoleInput(event.getCommand(), this.rconConsoleSource.createCommandSourceStack());
+            server.dispatchServerCommand(remoteConsole, serverCommand);
+            } // Paper
+            // CraftBukkit end
+        });
+        // Paper start
+        if (waitableArray[0] != null) {
+            //noinspection unchecked
+            Waitable<String> waitable = waitableArray[0];
+            try {
+                return waitable.get();
+            } catch (java.util.concurrent.ExecutionException e) {
+                throw new RuntimeException("Exception processing rcon command " + command, e.getCause());
+            } catch (InterruptedException e) {
+                Thread.currentThread().interrupt(); // Maintain interrupted state
+                throw new RuntimeException("Interrupted processing rcon command " + command, e);
+            }
+
+        }
+        // Paper end
+        return this.rconConsoleSource.getCommandResponse();
+    }
+
+    public void storeUsingWhiteList(boolean useWhitelist) {
+        this.settings.update((dedicatedserverproperties) -> {
+            return (DedicatedServerProperties) dedicatedserverproperties.whiteList.update(this.registryAccess(), useWhitelist);
+        });
+    }
+
+    @Override
+    public void stopServer() {
+        super.stopServer();
+        //SystemUtils.h(); // Paper - moved into super
+    }
+
+    @Override
+    public boolean isSingleplayerOwner(GameProfile profile) {
+        return false;
+    }
+
+    @Override
+    public int getScaledTrackingDistance(int initialDistance) {
+        return this.getProperties().entityBroadcastRangePercentage * initialDistance / 100;
+    }
+
+    @Override
+    public String getLevelIdName() {
+        return this.storageSource.getLevelId();
+    }
+
+    @Override
+    public boolean forceSynchronousWrites() {
+        return this.settings.getProperties().syncChunkWrites;
+    }
+
+    @Override
+    public TextFilter createTextFilterForPlayer(ServerPlayer player) {
+        return this.textFilterClient != null ? this.textFilterClient.createContext(player.getGameProfile()) : TextFilter.DUMMY;
+    }
+
+    @Override
+    public boolean isResourcePackRequired() {
+        return this.settings.getProperties().requireResourcePack;
+    }
+
+    @Nullable
+    @Override
+    public GameType getForcedGameType() {
+        return this.settings.getProperties().forceGameMode ? this.worldData.getGameType() : null;
+    }
+
+    @Nullable
+    private static Component parseResourcePackPrompt(DedicatedServerSettings propertiesLoader) {
+        String s = propertiesLoader.getProperties().resourcePackPrompt;
+
+        if (!Strings.isNullOrEmpty(s)) {
+            try {
+                return Component.Serializer.fromJson(s);
+            } catch (Exception exception) {
+                DedicatedServer.LOGGER.warn("Failed to parse resource pack prompt '{}'", s, exception);
+            }
+        }
+
+        return null;
+    }
+
+    @Nullable
+    @Override
+    public Component getResourcePackPrompt() {
+        return this.resourcePackPrompt;
+    }
+
+    // CraftBukkit start
+    public boolean isDebugging() {
+        return this.getProperties().debug;
+    }
+
+    @Override
+    public CommandSender getBukkitSender(CommandSourceStack wrapper) {
+        return console;
+    }
+    // CraftBukkit end
+}
diff --git a/src/main/java/net/pl3x/purpur/PurpurConfig.java.orig b/src/main/java/net/pl3x/purpur/PurpurConfig.java.orig
new file mode 100644
index 0000000000000000000000000000000000000000..7edf0510895ab1b2b01c77b70507a0d9bb525fe2
--- /dev/null
+++ b/src/main/java/net/pl3x/purpur/PurpurConfig.java.orig
@@ -0,0 +1,177 @@
+package net.pl3x.purpur;
+
+import co.aikar.timings.TimingsManager;
+import com.google.common.base.Throwables;
+import com.google.common.collect.ImmutableMap;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.entity.EntityDimensions;
+import net.minecraft.world.entity.EntityType;
+import net.pl3x.purpur.command.PurpurCommand;
+import org.bukkit.Bukkit;
+import org.bukkit.command.Command;
+import org.bukkit.configuration.ConfigurationSection;
+import org.bukkit.configuration.InvalidConfigurationException;
+import org.bukkit.configuration.file.YamlConfiguration;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Level;
+
+@SuppressWarnings("unused")
+public class PurpurConfig {
+    private static final String HEADER = "This is the main configuration file for Purpur.\n"
+            + "As you can see, there's tons to configure. Some options may impact gameplay, so use\n"
+            + "with caution, and make sure you know what each option does before configuring.\n"
+            + "\n"
+            + "If you need help with the configuration or have any questions related to Purpur,\n"
+            + "join us in our Discord guild.\n"
+            + "\n"
+            + "Website: https://github.com/pl3xgaming/Purpur \n"
+            + "Wiki: https://github.com/pl3xgaming/Purpur/wiki \n";
+    private static File CONFIG_FILE;
+    public static YamlConfiguration config;
+
+    private static Map<String, Command> commands;
+
+    static int version;
+    static boolean verbose;
+
+    public static void init(File configFile) {
+        CONFIG_FILE = configFile;
+        config = new YamlConfiguration();
+        try {
+            config.load(CONFIG_FILE);
+        } catch (IOException ignore) {
+        } catch (InvalidConfigurationException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Could not load purpur.yml, please correct your syntax errors", ex);
+            throw Throwables.propagate(ex);
+        }
+        config.options().header(HEADER);
+        config.options().copyDefaults(true);
+        verbose = getBoolean("verbose", false);
+
+        commands = new HashMap<>();
+        commands.put("purpur", new PurpurCommand("purpur"));
+
+        version = getInt("config-version", 22);
+        set("config-version", 22);
+
+        readConfig(PurpurConfig.class, null);
+    }
+
+    protected static void log(String s) {
+        if (verbose) {
+            log(Level.INFO, s);
+        }
+    }
+
+    protected static void log(Level level, String s) {
+        Bukkit.getLogger().log(level, s);
+    }
+
+    public static void registerCommands() {
+        for (Map.Entry<String, Command> entry : commands.entrySet()) {
+            MinecraftServer.getServer().server.getCommandMap().register(entry.getKey(), "Purpur", entry.getValue());
+        }
+    }
+
+    static void readConfig(Class<?> clazz, Object instance) {
+        for (Method method : clazz.getDeclaredMethods()) {
+            if (Modifier.isPrivate(method.getModifiers())) {
+                if (method.getParameterTypes().length == 0 && method.getReturnType() == Void.TYPE) {
+                    try {
+                        method.setAccessible(true);
+                        method.invoke(instance);
+                    } catch (InvocationTargetException ex) {
+                        throw Throwables.propagate(ex.getCause());
+                    } catch (Exception ex) {
+                        Bukkit.getLogger().log(Level.SEVERE, "Error invoking " + method, ex);
+                    }
+                }
+            }
+        }
+
+        try {
+            config.save(CONFIG_FILE);
+        } catch (IOException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Could not save " + CONFIG_FILE, ex);
+        }
+    }
+
+    private static void set(String path, Object val) {
+        config.addDefault(path, val);
+        config.set(path, val);
+    }
+
+    private static String getString(String path, String def) {
+        config.addDefault(path, def);
+        return config.getString(path, config.getString(path));
+    }
+
+    private static boolean getBoolean(String path, boolean def) {
+        config.addDefault(path, def);
+        return config.getBoolean(path, config.getBoolean(path));
+    }
+
+    private static double getDouble(String path, double def) {
+        config.addDefault(path, def);
+        return config.getDouble(path, config.getDouble(path));
+    }
+
+    private static int getInt(String path, int def) {
+        config.addDefault(path, def);
+        return config.getInt(path, config.getInt(path));
+    }
+
+    private static <T> List getList(String path, T def) {
+        config.addDefault(path, def);
+        return config.getList(path, config.getList(path));
+    }
+
+    static Map<String, Object> getMap(String path, Map<String, Object> def) {
+        if (def != null && config.getConfigurationSection(path) == null) {
+            config.addDefault(path, def);
+            return def;
+        }
+        return toMap(config.getConfigurationSection(path));
+    }
+
+    private static Map<String, Object> toMap(ConfigurationSection section) {
+        ImmutableMap.Builder<String, Object> builder = ImmutableMap.builder();
+        if (section != null) {
+            for (String key : section.getKeys(false)) {
+                Object obj = section.get(key);
+                if (obj != null) {
+                    builder.put(key, obj instanceof ConfigurationSection val ? toMap(val) : obj);
+                }
+            }
+        }
+        return builder.build();
+    }
+
+    public static boolean useAlternateKeepAlive = false;
+    private static void useAlternateKeepAlive() {
+        useAlternateKeepAlive = getBoolean("settings.use-alternate-keepalive", useAlternateKeepAlive);
+    }
+
+    public static boolean dontSendUselessEntityPackets = false;
+    private static void dontSendUselessEntityPackets() {
+        dontSendUselessEntityPackets = getBoolean("settings.dont-send-useless-entity-packets", dontSendUselessEntityPackets);
+    }
+
+    public static double laggingThreshold = 19.0D;
+    private static void tickLoopSettings() {
+        laggingThreshold = getDouble("settings.lagging-threshold", laggingThreshold);
+    }
+
+    public static boolean tpsCatchup = true;
+    private static void tpsCatchup() {
+        tpsCatchup = getBoolean("settings.tps-catchup", tpsCatchup);
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index c3a256d0ccb9fb44a5a1f9ffa2d48542ef4e857b..25c9626d7a561248b6990bfe030b836d2959fef2 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -251,7 +251,7 @@ import javax.annotation.Nullable; // Paper
 import javax.annotation.Nonnull; // Paper
 
 public final class CraftServer implements Server {
-    private final String serverName = "Airplane"; // Paper // Airplane
+    private final String serverName = "Fiadelity"; // Paper // Airplane // Fiadelity
     private final String serverVersion;
     private final String bukkitVersion = Versioning.getBukkitVersion();
     private final Logger logger = Logger.getLogger("Minecraft");
diff --git a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
index 1788d79ea489e446d3d9f541693d4ba3dfc26015..8dbdee4820deba557efd5db9a9a5a98e3dfd26b6 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
@@ -1,29 +1,9 @@
 package org.bukkit.craftbukkit.util;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.Properties;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 import org.bukkit.Bukkit;
 
 public final class Versioning {
     public static String getBukkitVersion() {
-        String result = "Unknown-Version";
-
-        InputStream stream = Bukkit.class.getClassLoader().getResourceAsStream("META-INF/maven/gg.airplane/airplane-api/pom.properties"); // Tuinity // Airplane
-        Properties properties = new Properties();
-
-        if (stream != null) {
-            try {
-                properties.load(stream);
-
-                result = properties.getProperty("version");
-            } catch (IOException ex) {
-                Logger.getLogger(Versioning.class.getName()).log(Level.SEVERE, "Could not get Bukkit version!", ex);
-            }
-        }
-
-        return result;
+        return "1.17.1-R0.1-SNAPSHOT"; // Fiadelity - hardcode BukkitVersion
     }
 }
diff --git a/src/main/resources/logo.png b/src/main/resources/logo.png
index a7d785f60c884ee4ee487cc364402d66c3dc2ecc..2d11b95d0ca2a17817c0bcba87723f5f64f5e9b6 100644
GIT binary patch
literal 11560
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

literal 14310
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%0ABLt+m?son?j
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
WX&3$!%>|s_1IbA#OV)^+1pg1OmmZn`

