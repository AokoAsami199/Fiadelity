From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Nassim Jahnke <jahnke.nassim@gmail.com>
Date: Wed, 1 Dec 2021 12:36:25 +0100
Subject: [PATCH] (Paper-1.18.2) Prevent sending oversized item data in
 equipment and metadata


diff --git a/src/main/java/net/minecraft/network/syncher/EntityDataSerializers.java b/src/main/java/net/minecraft/network/syncher/EntityDataSerializers.java
index 027262d2c730768ee676bf703a2522cb43d872b4..5d528b6dc418e41d1bc070305b14756fffcd10ca 100644
--- a/src/main/java/net/minecraft/network/syncher/EntityDataSerializers.java
+++ b/src/main/java/net/minecraft/network/syncher/EntityDataSerializers.java
@@ -127,7 +127,7 @@ public class EntityDataSerializers {
     public static final EntityDataSerializer<ItemStack> ITEM_STACK = new EntityDataSerializer<ItemStack>() {
         @Override
         public void write(FriendlyByteBuf buf, ItemStack value) {
-            buf.writeItem(value);
+            buf.writeItem(net.minecraft.world.entity.LivingEntity.sanitizeItemStack(value, false)); // Paper - prevent oversized data
         }
 
         @Override
diff --git a/src/main/java/net/minecraft/server/level/ServerEntity.java b/src/main/java/net/minecraft/server/level/ServerEntity.java
index 1ee128fb683d2c0f2e307a7bf033d15ae7b0221e..2f72e877fba7885b78221206b21798187ba2b1a7 100644
--- a/src/main/java/net/minecraft/server/level/ServerEntity.java
+++ b/src/main/java/net/minecraft/server/level/ServerEntity.java
@@ -339,7 +339,10 @@ public class ServerEntity {
                 ItemStack itemstack = ((LivingEntity) this.entity).getItemBySlot(enumitemslot);
 
                 if (!itemstack.isEmpty()) {
-                    list.add(Pair.of(enumitemslot, itemstack.copy()));
+                    // Paper start - prevent oversized data
+                    final ItemStack sanitized = LivingEntity.sanitizeItemStack(itemstack.copy(), false);
+                    list.add(Pair.of(enumitemslot, sanitized));
+                    // Paper end
                 }
             }
 
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 8bb947ed8a13b0fb74446b91f3385f0c465e01f8..6d9f32397f792b9c33b1f3f7903c01de54f70f73 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -3097,7 +3097,10 @@ public abstract class LivingEntity extends Entity {
         equipment.forEach((enumitemslot, itemstack) -> {
             ItemStack itemstack1 = itemstack.copy();
 
-            list.add(Pair.of(enumitemslot, itemstack1));
+            // Paper start - prevent oversized data
+            ItemStack toSend = sanitizeItemStack(itemstack1, true);
+            list.add(Pair.of(enumitemslot, toSend));
+            // Paper end
             switch (enumitemslot.getType()) {
                 case HAND:
                     this.setLastHandItem(enumitemslot, itemstack1);
@@ -3110,6 +3113,34 @@ public abstract class LivingEntity extends Entity {
         ((ServerLevel) this.level).getChunkSource().broadcast(this, new ClientboundSetEquipmentPacket(this.getId(), list));
     }
 
+    // Paper start - prevent oversized data
+    public static ItemStack sanitizeItemStack(final ItemStack itemStack, final boolean copyItemStack) {
+        if (itemStack.isEmpty() || !itemStack.hasTag()) {
+            return itemStack;
+        }
+
+        final ItemStack copy = copyItemStack ? itemStack.copy() : itemStack;
+        final CompoundTag tag = copy.getTag();
+        if (copy.is(Items.BUNDLE) && tag.get("Items") instanceof ListTag oldItems && !oldItems.isEmpty()) {
+            // Bundles change their texture based on their fullness.
+            org.bukkit.inventory.meta.BundleMeta bundleMeta = (org.bukkit.inventory.meta.BundleMeta) copy.asBukkitMirror().getItemMeta();
+            int sizeUsed = 0;
+            for (org.bukkit.inventory.ItemStack item : bundleMeta.getItems()) {
+                int scale = 64 / item.getMaxStackSize();
+                sizeUsed += scale * item.getAmount();
+            }
+            // Now we add a single fake item that uses the same amount of slots as all other items.
+            ListTag items = new ListTag();
+            items.add(new ItemStack(Items.PAPER, sizeUsed).save(new CompoundTag()));
+            tag.put("Items", items);
+        }
+        if (tag.get("BlockEntityTag") instanceof CompoundTag blockEntityTag) {
+            blockEntityTag.remove("Items");
+        }
+        return copy;
+    }
+    // Paper end
+
     private ItemStack getLastArmorItem(EquipmentSlot slot) {
         return (ItemStack) this.lastArmorItemStacks.get(slot.getIndex());
     }
